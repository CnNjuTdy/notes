# 算法导论

## 第一部分：基础知识

### 第1章 算法在计算中的运用

#### 1.1 算法

算法是定义良好的计算过程，它取一个或一组值作为输入，并产生出一个值或一个组作为输出。如果对于每个输入实例算法都以正确的输出停机，则称该算法是正确的，并称算法正确地解决了给定的计算问题。有趣的算法问题共有的两个特征是存在许多候选解，存在于实际的应用的当中。

数据结构是一种存储和组织数据的方式，旨在便于访问和修改。没有任何一种数据结构时永远有效果的，所有重要的是知道击中数据结构的优势和局限。

#### 1.2 作为一种技术的算法

计算机的速度很快，但是不是无线快，存储器的确很廉价，但是不是不要钱的，所以时间和空间都是一种计算资源，应该明确得使用这些资源。对于某些特定的问题，更好的算法会给运算速度带来指数级别的提升。

算法和计算机硬件一样，是一种技术。

### 第2章 算法基础

本章介绍了一个贯穿本书的框架，后续的算法设计与分析都是在这个框架中进行的。

#### 2.1 插入排序

伪代码在许多方面和C，C++，Java很类似，但是拥有一些额外的优点：

- 清晰简洁，易于理解
- 方便说明问题的本质
- 可以忽略一些软件工程的问题

插入排序对于少量元素是很有效果的。它类似整理扑克牌的过程，即每次从桌上顶端拿一张扑克牌，然后插到手中的合适位置，使得手中的扑克牌始终是排好序的，直到桌上没有扑克牌时，手中的扑克牌就是排好序的。

> 算法2.1.1 插入排序

循环不变式可以用来理解算法的正确性，关于循环不变式（数学归纳法）

- 循环的第一次迭代之前，它是正确的
- 如果循环的某次迭代之前它是正确的，那么下次迭代之前依然正确
- 循环结束时它也是正确的

伪代码相关约定

- 允许连环赋值
- 变量是局部的，除非特别说明，一般不使用全局变量
- 关键字error可以用来表示程序出错，这里不再处理

#### 2.2 分析算法

用于分析算法的计算机是RAM模型，该模型的计算机是典型的冯诺依曼架构，其cpu包含真实计算机中常见的指令，例如算数指令，数据移动指令和控制指令，每条这样的指令时长都是常数。本书基本不考虑内存层次对算法分析的影响，但是实际上的计算机的内存模型对算法的效率有一定影响。

插入排序算法的时间复杂度是$O(n^2)$

#### 2.3 设计算法

插入排序使用了增量方法，在排序子数组$A[0,1,2,3,\dots,j-1]$之后，插入$A[j]$使得$A[0,1,2,3,\dots,j]$

##### 2.3.1 分治法

分治法将原问题分解为几个规模较小但是类似于原问题的子问题，递归的求解这些问题，然后合并子问题结果获得原问题结果。分治法在每次递归时有三个步骤：

- 分解：分解原问题为若干子问题，这些子问题是原问题规模比较小的实例
- 解决：解决这些子问题，递归地求解各个子问题。如果子问题规模较小，可以直接求解
- 合并：合并这些子问题的解为原问题的解答

归并排序算法完全遵循分治模式：

- 分解：分解待排序的n个元素的序列形成2个n/2个元素的子序列
- 解决：使用归并排序递归地排序子序列
- 合并：合并两个已排序的子序列形成原序列的排序序列

归并排序的关键在于第三步，即如何归并两个已经排好序的序列。具体办法是每次从两堆数据中比较第一个数，将比较大的留下，小的那个放在结果序列的下一个，再重新从两堆数据中比较第一个数据，直到两堆数据有一个为空，则把剩下的那堆数据直接放在结果序列的最后。

> 算法2.3.1 归并排序

##### 2.3.2 分析分治算法

分治算法的算法复杂度通常都是$O(f(n)log_2n)$的，其中合并步骤使用的算法复杂度是$O(f(n)$，由于归并排序算法归并一步的复杂度是$O(n)$，因此归并排序算法的复杂度是$O(nlog_2n)$

尽管看起来归并排序效率更高，但由于一些常数项的干扰（常系数），在n比较少的时候，插入算法反而更有效。