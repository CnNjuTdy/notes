> 尽量少的复杂度数学计算……专注算法，能看出复杂度结果即可

# 算法导论

## 第一部分：基础知识

### 第1章 算法在计算中的运用

#### 1.1 算法

算法是定义良好的计算过程，它取一个或一组值作为输入，并产生出一个值或一个组作为输出。如果对于每个输入实例算法都以正确的输出停机，则称该算法是正确的，并称算法正确地解决了给定的计算问题。有趣的算法问题共有的两个特征是存在许多候选解，存在于实际的应用的当中。

数据结构是一种存储和组织数据的方式，旨在便于访问和修改。没有任何一种数据结构时永远有效果的，所有重要的是知道击中数据结构的优势和局限。

#### 1.2 作为一种技术的算法

计算机的速度很快，但是不是无线快，存储器的确很廉价，但是不是不要钱的，所以时间和空间都是一种计算资源，应该明确得使用这些资源。对于某些特定的问题，更好的算法会给运算速度带来指数级别的提升。

算法和计算机硬件一样，是一种技术。

### 第2章 算法基础

本章介绍了一个贯穿本书的框架，后续的算法设计与分析都是在这个框架中进行的。

#### 2.1 插入排序

伪代码在许多方面和C，C++，Java很类似，但是拥有一些额外的优点：

- 清晰简洁，易于理解
- 方便说明问题的本质
- 可以忽略一些软件工程的问题

插入排序对于少量元素是很有效果的。它类似整理扑克牌的过程，即每次从桌上顶端拿一张扑克牌，然后插到手中的合适位置，使得手中的扑克牌始终是排好序的，直到桌上没有扑克牌时，手中的扑克牌就是排好序的。

> 算法2.1.1 插入排序

循环不变式可以用来理解算法的正确性，关于循环不变式（数学归纳法）

- 循环的第一次迭代之前，它是正确的
- 如果循环的某次迭代之前它是正确的，那么下次迭代之前依然正确
- 循环结束时它也是正确的

伪代码相关约定

- 允许连环赋值
- 变量是局部的，除非特别说明，一般不使用全局变量
- 关键字error可以用来表示程序出错，这里不再处理

#### 2.2 分析算法

用于分析算法的计算机是RAM模型，该模型的计算机是典型的冯诺依曼架构，其cpu包含真实计算机中常见的指令，例如算数指令，数据移动指令和控制指令，每条这样的指令时长都是常数。本书基本不考虑内存层次对算法分析的影响，但是实际上的计算机的内存模型对算法的效率有一定影响。

插入排序算法的时间复杂度是$O(n^2)$

#### 2.3 设计算法

插入排序使用了增量方法，在排序子数组$A[0,1,2,3,\dots,j-1]$之后，插入$A[j]$使得$A[0,1,2,3,\dots,j]$

##### 2.3.1 分治法

分治法将原问题分解为几个规模较小但是类似于原问题的子问题，递归的求解这些问题，然后合并子问题结果获得原问题结果。分治法在每次递归时有三个步骤：

- 分解：分解原问题为若干子问题，这些子问题是原问题规模比较小的实例
- 解决：解决这些子问题，递归地求解各个子问题。如果子问题规模较小，可以直接求解
- 合并：合并这些子问题的解为原问题的解答

归并排序算法完全遵循分治模式：

- 分解：分解待排序的n个元素的序列形成2个n/2个元素的子序列
- 解决：使用归并排序递归地排序子序列
- 合并：合并两个已排序的子序列形成原序列的排序序列

归并排序的关键在于第三步，即如何归并两个已经排好序的序列。具体办法是每次从两堆数据中比较第一个数，将比较大的留下，小的那个放在结果序列的下一个，再重新从两堆数据中比较第一个数据，直到两堆数据有一个为空，则把剩下的那堆数据直接放在结果序列的最后。

> 算法2.3.1 归并排序

##### 2.3.2 分析分治算法

分治算法的算法复杂度通常都是$O(f(n)log_2n)$的，其中合并步骤使用的算法复杂度是$O(f(n)$，由于归并排序算法归并一步的复杂度是$O(n)$，因此归并排序算法的复杂度是$O(nlog_2n)$

尽管看起来归并排序效率更高，但由于一些常数项的干扰（常系数），在n比较少的时候，插入算法反而更有效。

### 第3章 函数的增长

尽管可以精确的计算某个函数的运行速度，但是我们通常不那么做，因为当输入规模扩大时，常数和系数的影响通常可以忽略不计。

#### 3.1 渐进记号

- $\Theta$记号：$\Theta(g(x))=\{f(x)|\exist c_1>0,c_2>0,n_0>0,st \ c_1g(x)\le f(x) \le c_2g(x) \ \forall x>n_0\}$
  - $\Theta$记号描述了函数的渐进上界
- $O$记号：$O(g(x))=\{f(x)|\exist c>0,n_0>0,st \ 0\le f(x) \le cg(x) \ \forall x>n_0$
  - $O$记号仅描述函数的上界，并不要求是精确的，例如$n \in O(n^2)$
- $\Omega$记号：$O(g(x))=\{f(x)|\exist c>0,n_0>0,st \ 0 \le cg(x) \le f(x)  \ \forall x>n_0$
  - $\Omega$记号描述了函数的下界

以上三个符号具有传递性，自反性，对称性。

#### 3.2 渐进记号和标准函数

- 关于阶乘函数的上界：$\lg(n!)=\Theta(nln(n))$
- 多重函数：$f^{(i)}(x)=f(f^{(i-1)}(x))$

### 第4章 分治策略

在分治问题中，我们递归地解决问题，在每次递归中有三个步骤：

- 分解：分解原问题为若干子问题，这些子问题是原问题规模比较小的实例
- 解决：解决这些子问题，递归地求解各个子问题。如果子问题规模较小，可以直接求解
- 合并：合并这些子问题的解为原问题的解答

当问题比较大，还需要递归的时候，称这个问题进入了递归情况，当问题比较小，可以直接求解不用递归的时候，我们认为问题已经触底，进入了基本情况。

递归式与分治法是紧密相连的，尤其是在计算复杂度时。递归式是一个等式，它通过更小的输入上的函数值来描述一个函数，例如在归并排序中，时间复杂度的递归式是：
$$
T(n) = 2(T(n/2))+\Theta(n)
$$

#### 4.1 最大子数组问题

有一个最大收益问题，符号化之后的描述是在一个数组$A=[a_1,a_2,\dots,a_n]$中，找到两个下标$i<j$使得$A[j]-A[i]$最大。

- 暴力求解方法，这样的下标$i,j$的个数是$C_n^2$个，逐一算出结果比较即可。时间复杂度是$O(n^2)$。
- 换个角度转化问题，即将数组A变化成$A=[a_1,a_2-a1,\dots,a_n-a_{n-1}]$，这样问题就变成了求一个数字的子数组，使其和最大，即最大子数组问题。
  - 考虑用分治算法，最长子数组的情况有三种，全在左边，全在右边和跨越中点。
  - 全在左边和全在右边的算法和原问题是一样的，是一个简化版本的最大子数组问题
  - 跨越中点的最长子数组可以用$O(n)$时间完成。

> 4.1.1 最大子数组分治算法

最大子数组分治算法的时间复杂度是$O(nlog_2n)$

#### 4.2 矩阵乘法问题

如果$A$和$B$都是$n \times n$的矩阵，求解$C=A \cdot B$

- 暴力求解方法，$c_{i,j}=\sum^n_\limits {k=1}a_{i,k}b_{k,j}$，这个算法的复杂度是$O(n^3)$
- 考虑分治方法。最终生成的Strassen算法的算法复杂度是$O(n^{log_27})$

#### 4.3 用代入法求解递归式

代入法求解递归式需要先猜测解的形式，再用数学归纳法证明

#### 4.4 用递归树法求解递归式

递归树可以先计算叶节点的时间消耗，再往根节点叠加，例如归并排序在最底层有n个叶节点，一共有$log_2n$层，所以时间复杂度是$nlog_2n$

#### 4.5 主方法求解递归式

如果$T(n) = T(n/b)+O(f(n))$，那么$T(n) \in O(f(n)log_bn)$

### 第5章 概率分析和随机算法

#### 5.1 雇佣问题

雇佣问题的描述是，假定有n个面试者，你需要逐个面试，并在遇到一个目前最好的面试者时，雇佣他。面试费用比较少，是$c_i$，雇佣费用比较多，是$c_h$，要估计你的花费是多少。

最坏情况：如果面试者质量是递增的，那么一共需要雇佣n次，总费用$cost=n(c_i+c_h)$

最好情况：如果面试者质量是递减的，那么一共只需要雇佣1次，总费用$cost = nc_i+c_h$

随机情况（一般情况）：假定面试质量是随机的，这个问题可以这样考虑，即n个面试者的质量是递增的，但是由于你不知道这件事，你是随机挑选面试者的。也可以这么考虑，n个面试者的质量序列是递增序列的一个随机排列。

如果一个算法不仅由输入决定，还由随机数生成器确定，那么称这个算法是随机的。

#### 5.2 指示器随机变量

对于事件A，指示器随机变量$I(A)$表示A是否发生，$I(A)=1$当且仅当A发生。

对于雇佣问题，如果面试者的质量序列是递增序列的一个随机排列在面试第i个人时，那么雇佣他的概率是1/i（当且仅当他是这i个人当中最好的）。因此雇佣问题的平均花费是$cost=nc_i+\sum_\limits {i=1}^n(1/i)=nc_i+c_hln \ n$。

#### 5.3 随机算法

在雇用问题中，随机发生在输入上（即面试者的质量序列），但是我们可以把这种随机放在算法里，即每次算法随机排列受试者顺序。这个问题可以抽象形式化为如何随机排列一个数组。

一个简单的想法是，给数组中的每个数字赋予一个随机权重，然后按照权重排序

> 排序方法随机排列数组

还有一个方法是，循环n次，每次交换第i个数据和后n-i个数据中的随机数据

> 交换方法随机排列数组

可以用数学归纳法证明这两种办法产生的序列都是随机的，即产生的每个特定的序列的概率是$\frac{1}{n!}$。

## 第二部分： 排序和顺序统计量

### 第6章 堆排序

#### 6.1 堆

（二叉）堆是一个近似的

## 第八部分：附录

### 附录 B 集合等离散数学内容

#### B.5 树

