> 尽量少的复杂度数学计算……专注算法，能看出复杂度结果即可

# 算法导论

## 第一部分：基础知识

### 第1章 算法在计算中的运用

#### 1.1 算法

算法是定义良好的计算过程，它取一个或一组值作为输入，并产生出一个值或一个组作为输出。如果对于每个输入实例算法都以正确的输出停机，则称该算法是正确的，并称算法正确地解决了给定的计算问题。有趣的算法问题共有的两个特征是存在许多候选解，存在于实际的应用的当中。

数据结构是一种存储和组织数据的方式，旨在便于访问和修改。没有任何一种数据结构时永远有效果的，所有重要的是知道击中数据结构的优势和局限。

#### 1.2 作为一种技术的算法

计算机的速度很快，但是不是无线快，存储器的确很廉价，但是不是不要钱的，所以时间和空间都是一种计算资源，应该明确得使用这些资源。对于某些特定的问题，更好的算法会给运算速度带来指数级别的提升。

算法和计算机硬件一样，是一种技术。

### 第2章 算法基础

本章介绍了一个贯穿本书的框架，后续的算法设计与分析都是在这个框架中进行的。

#### 2.1 插入排序

伪代码在许多方面和C，C++，Java很类似，但是拥有一些额外的优点：

- 清晰简洁，易于理解
- 方便说明问题的本质
- 可以忽略一些软件工程的问题

插入排序对于少量元素是很有效果的。它类似整理扑克牌的过程，即每次从桌上顶端拿一张扑克牌，然后插到手中的合适位置，使得手中的扑克牌始终是排好序的，直到桌上没有扑克牌时，手中的扑克牌就是排好序的。

> 算法2.1.1 插入排序

循环不变式可以用来理解算法的正确性，关于循环不变式（数学归纳法）

- 循环的第一次迭代之前，它是正确的
- 如果循环的某次迭代之前它是正确的，那么下次迭代之前依然正确
- 循环结束时它也是正确的

伪代码相关约定

- 允许连环赋值
- 变量是局部的，除非特别说明，一般不使用全局变量
- 关键字error可以用来表示程序出错，这里不再处理

#### 2.2 分析算法

用于分析算法的计算机是RAM模型，该模型的计算机是典型的冯诺依曼架构，其cpu包含真实计算机中常见的指令，例如算数指令，数据移动指令和控制指令，每条这样的指令时长都是常数。本书基本不考虑内存层次对算法分析的影响，但是实际上的计算机的内存模型对算法的效率有一定影响。

插入排序算法的时间复杂度是$O(n^2)$

#### 2.3 设计算法

插入排序使用了增量方法，在排序子数组$A[0,1,2,3,\dots,j-1]$之后，插入$A[j]$使得$A[0,1,2,3,\dots,j]$

##### 2.3.1 分治法

分治法将原问题分解为几个规模较小但是类似于原问题的子问题，递归的求解这些问题，然后合并子问题结果获得原问题结果。分治法在每次递归时有三个步骤：

- 分解：分解原问题为若干子问题，这些子问题是原问题规模比较小的实例
- 解决：解决这些子问题，递归地求解各个子问题。如果子问题规模较小，可以直接求解
- 合并：合并这些子问题的解为原问题的解答

归并排序算法完全遵循分治模式：

- 分解：分解待排序的n个元素的序列形成2个n/2个元素的子序列
- 解决：使用归并排序递归地排序子序列
- 合并：合并两个已排序的子序列形成原序列的排序序列

归并排序的关键在于第三步，即如何归并两个已经排好序的序列。具体办法是每次从两堆数据中比较第一个数，将比较大的留下，小的那个放在结果序列的下一个，再重新从两堆数据中比较第一个数据，直到两堆数据有一个为空，则把剩下的那堆数据直接放在结果序列的最后。

> 算法2.3.1 归并排序

##### 2.3.2 分析分治算法

分治算法的算法复杂度通常都是$O(f(n)log_2n)$的，其中合并步骤使用的算法复杂度是$O(f(n)$，由于归并排序算法归并一步的复杂度是$O(n)$，因此归并排序算法的复杂度是$O(nlog_2n)$

尽管看起来归并排序效率更高，但由于一些常数项的干扰（常系数），在n比较少的时候，插入算法反而更有效。

### 第3章 函数的增长

尽管可以精确的计算某个函数的运行速度，但是我们通常不那么做，因为当输入规模扩大时，常数和系数的影响通常可以忽略不计。

#### 3.1 渐进记号

- $\Theta$记号：$\Theta(g(x))=\{f(x)|\exist c_1>0,c_2>0,n_0>0,st \ c_1g(x)\le f(x) \le c_2g(x) \ \forall x>n_0\}$
  - $\Theta$记号描述了函数的渐进上界
- $O$记号：$O(g(x))=\{f(x)|\exist c>0,n_0>0,st \ 0\le f(x) \le cg(x) \ \forall x>n_0$
  - $O$记号仅描述函数的上界，并不要求是精确的，例如$n \in O(n^2)$
- $\Omega$记号：$O(g(x))=\{f(x)|\exist c>0,n_0>0,st \ 0 \le cg(x) \le f(x)  \ \forall x>n_0$
  - $\Omega$记号描述了函数的下界

以上三个符号具有传递性，自反性，对称性。

#### 3.2 渐进记号和标准函数

- 关于阶乘函数的上界：$\lg(n!)=\Theta(nln(n))$
- 多重函数：$f^{(i)}(x)=f(f^{(i-1)}(x))$

### 第4章 分治策略

在分治问题中，我们递归地解决问题，在每次递归中有三个步骤：

- 分解：分解原问题为若干子问题，这些子问题是原问题规模比较小的实例
- 解决：解决这些子问题，递归地求解各个子问题。如果子问题规模较小，可以直接求解
- 合并：合并这些子问题的解为原问题的解答

当问题比较大，还需要递归的时候，称这个问题进入了递归情况，当问题比较小，可以直接求解不用递归的时候，我们认为问题已经触底，进入了基本情况。

递归式与分治法是紧密相连的，尤其是在计算复杂度时。递归式是一个等式，它通过更小的输入上的函数值来描述一个函数，例如在归并排序中，时间复杂度的递归式是：
$$
T(n) = 2(T(n/2))+\Theta(n)
$$

#### 4.1 最大子数组问题

有一个最大收益问题，符号化之后的描述是在一个数组$A=[a_1,a_2,\dots,a_n]$中，找到两个下标$i<j$使得$A[j]-A[i]$最大。

- 暴力求解方法，这样的下标$i,j$的个数是$C_n^2$个，逐一算出结果比较即可。时间复杂度是$O(n^2)$。
- 换个角度转化问题，即将数组A变化成$A=[a_1,a_2-a1,\dots,a_n-a_{n-1}]$，这样问题就变成了求一个数字的子数组，使其和最大，即最大子数组问题。
  - 考虑用分治算法，最长子数组的情况有三种，全在左边，全在右边和跨越中点。
  - 全在左边和全在右边的算法和原问题是一样的，是一个简化版本的最大子数组问题
  - 跨越中点的最长子数组可以用$O(n)$时间完成。

> 4.1.1 最大子数组分治算法

最大子数组分治算法的时间复杂度是$O(nlog_2n)$

#### 4.2 矩阵乘法问题

如果$A$和$B$都是$n \times n$的矩阵，求解$C=A \cdot B$

- 暴力求解方法，$c_{i,j}=\sum^n_\limits {k=1}a_{i,k}b_{k,j}$，这个算法的复杂度是$O(n^3)$
- 考虑分治方法。最终生成的Strassen算法的算法复杂度是$O(n^{log_27})$

#### 4.3 用代入法求解递归式

代入法求解递归式需要先猜测解的形式，再用数学归纳法证明

#### 4.4 用递归树法求解递归式

递归树可以先计算叶节点的时间消耗，再往根节点叠加，例如归并排序在最底层有n个叶节点，一共有$log_2n$层，所以时间复杂度是$nlog_2n$

#### 4.5 主方法求解递归式

如果$T(n) = T(n/b)+O(f(n))$，那么$T(n) \in O(f(n)log_bn)$

### 第5章 概率分析和随机算法

#### 5.1 雇佣问题

雇佣问题的描述是，假定有n个面试者，你需要逐个面试，并在遇到一个目前最好的面试者时，雇佣他。面试费用比较少，是$c_i$，雇佣费用比较多，是$c_h$，要估计你的花费是多少。

最坏情况：如果面试者质量是递增的，那么一共需要雇佣n次，总费用$cost=n(c_i+c_h)$

最好情况：如果面试者质量是递减的，那么一共只需要雇佣1次，总费用$cost = nc_i+c_h$

随机情况（一般情况）：假定面试质量是随机的，这个问题可以这样考虑，即n个面试者的质量是递增的，但是由于你不知道这件事，你是随机挑选面试者的。也可以这么考虑，n个面试者的质量序列是递增序列的一个随机排列。

如果一个算法不仅由输入决定，还由随机数生成器确定，那么称这个算法是随机的。

#### 5.2 指示器随机变量

对于事件A，指示器随机变量$I(A)$表示A是否发生，$I(A)=1$当且仅当A发生。

对于雇佣问题，如果面试者的质量序列是递增序列的一个随机排列在面试第i个人时，那么雇佣他的概率是1/i（当且仅当他是这i个人当中最好的）。因此雇佣问题的平均花费是$cost=nc_i+\sum_\limits {i=1}^n(1/i)=nc_i+c_hln \ n$。

#### 5.3 随机算法

在雇用问题中，随机发生在输入上（即面试者的质量序列），但是我们可以把这种随机放在算法里，即每次算法随机排列受试者顺序。这个问题可以抽象形式化为如何随机排列一个数组。

一个简单的想法是，给数组中的每个数字赋予一个随机权重，然后按照权重排序

> 5.3.1 排序方法随机排列数组

还有一个方法是，循环n次，每次交换第i个数据和后n-i个数据中的随机数据

> 5.3.2 交换方法随机排列数组

可以用数学归纳法证明这两种办法产生的序列都是随机的，即产生的每个特定的序列的概率是$\frac{1}{n!}$。

## 第二部分： 排序和顺序统计量

### 第6章 堆排序

#### 6.1 堆

> 数据结构: Heap

（二叉）堆是一个近似的完全二叉树，它只有叶子部分是不满的，并且是从左到右依次排列的。因此堆可以用一个数组$A=[1,2,3\dots,A.heap-size]$来表示，在树的根节点是$A[1]$的情形下，某个节点i的左右节点和父节点分别是：
$$
left(i)=2*i \\
right(i)=2*i+1 \\
parent(i)=i/2
$$
在很多计算机里面，这三个操作都可以用位级运算来完成，即左移1位，左移1位并加1，右移一位，所以计算机对树的操作是很快的。

最大堆：$A[parent(i)]\ge A[i]$，i不是根节点

最小堆：$A[parent(i)] \le A[i]$，i不是根节点

堆中某个节点的高度定义为这个节点到根节点最短路径的长度，堆的高度是叶节点的高度。在很多时候，堆上的操作的时间最多与堆的高度成正比。

#### 6.2 维护堆的性质

MAX-HEAPIFY过程维护了堆的性质，它的输入是数组A和下标i，并且假定left(i)和right(i)都已经是最大堆，只有i不一定是。这时候需要调整堆使其变成一个最大堆。

思路在于，在A[i],A[left(i)],A[right(i)]中挑出一个最大的，如果这最大的是i，那么程序已经结束。如果不是，则交换A[i]和A[max]，并在现在的子树中调用MAX-HEAPIFY函数。

> 6.2.1 MAX-HEAPIFY和MIN-HEAPINFY过程

#### 6.3 建堆

有了上面的算法，建堆时由底向上，依次调用heapify过程，就可以建立一个最大（小）堆。这个建堆过程的时间复杂度是线性的（在下面是最快的）。

> 6.3.1 建堆过程

#### 6.4 堆排序

利用最大（小）堆的性质，可以排序一个数组，具体做法构建一个最大堆，然后将根节点放在队列的末尾，并把堆的大小减一，之后调整堆使其成为一个最大堆，重复上面过程。这个过程的时间复杂度是$O(nlgn)$。

> 6.4.1 堆排序

#### 6.5 优先队列

快速排序的性能一般优于堆排序，但是除了排序之外，堆还有一个作用，那就是优先队列。

优先队列是一种维护了一组元素构成的集合S的数据结构，每个元素都有一个主键关键字，它支持的操作包括插入，返回最大（小）关键字元素，去掉并返回最大（小）关键字元素，增大（减小）元素的关键字。最大优先队列的用处包括批处理时决定作业优先级和执行顺序等等。最小优先队列的用处包括在处理事件响应时按照时间来处理等等。

> 数据结构 优先队列

### 第7章 快速排序

#### 7.1 快速排序描述

快速排序是一个分治思想的排序算法。它主要分为三步：

- 分解：将数组$A[p,\dots,r]$分为两个子数组（可以为空）$A[p,q-1]$和$A[r+1,r]$，使得前一个数组中的所有数小于$A[q]$，后一个数组中的所有数大于$A[q]$。寻找下标q也是算法的一部分。
- 解决：递归调用分解算法
- 合并：不需要合并（原址排序的）

> 7.1.1 快速排序

#### 7.2 快速排序的性能

最坏情况下，两个子问题分别包含n-1个元素和0个元素，这时候性能是$O(n^2)$

当数组比较均衡，即两个子问题分别包含n/2个元素的时候，性能是$O(nlgn)$

#### 7.3 快速排序的随机化版本

上面的快速排序实际上是将最后一个元素改到了数组中间部分（作为分割点），实际上可以不使用$A[r]$作为主元，而是随机挑选主元。

#### 7.4 随机化版本的性能

随机版本的最差性能也是$O(n^2)$，平均性能是$O(nlgn)$

### 第8章 线性时间排序

归并排序和堆排序的最差情况和快速排序的平均情况时间复杂度都是$O(nlgn)$，这些排序都是基于比较的，即定义了两个元素之间的比较规则（例如实数的大小）。

#### 8.1 排序算法的下界

定理：在最坏情况下，任何比较排序算法都需要至少$nlgn$次比较。

#### 8.2 计数排序





## 第八部分：附录

### 附录 B 集合等离散数学内容

#### B.5 树

