在IoC容器中装配Bean

# 在IoC容器中装配Bean

## 1. Spring配置概述

### 1.1 Spring容器高层视图

![](img/4_1.png)

Spring容器在启动时，会经历以下几个步骤：

- 读取应用程序提供的bean信息
- 在Spring容器中生成一份对应的Bean配置注册表
- 根据这张注册表实例化Bean，装配好Bean之间的依赖关系
- 为上层应用提供准备就绪的运行环境

### 1.2 基于XML的配置

基于 Schema配置格式

```xml
<beans xmlns="http://www.springframework.org/schema/beans"//默认命名空间
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" //xsi标准命名空间
       xmlns:aop="http://www.springframework.org/schema/aop"//自定义命名空间，aop是该命名空间简称
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd">//为每个命名空间准备具体的Schema文件
  <!--默认命名空间的配置-->
  <bean id="foo" class="com.baobaotao.Foo"/>
  <!--AOP命名空间的配置-->
  <aop:config>
  	<aop:advisor pointcut="execution(**..PetStoreFacade.*(..)" advice-ref="txAdvice">
  </aop:config>
  </beans>
```

文档当中没有命名空间前缀的元素都属于默认命名空间，像\<aop:config\>表示是aop命名空间下的config元素。

## 2. Bean基本配置

### 2.1 装配一个bean

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <bean id="GeLi" class="com.demo05.LiuDeHua"/>
    <bean id="MoAttack" class="com.demo05.MoAttack"/>
</beans>
```

### 2.2 bean的命名

可以使用`name`和`id`进行对bean进行命名，但是id在IoC容器中是不能重复的，不过name可以，所以我们尽量使用id以免造成意外。

## 3 依赖注入

### 3.1 属性注入

采用`setXxx`方法进行注入，是最常使用的注入方式

属性注入的bean要求和J2EE规范中的JavaBean很相似，必须要有不带参数的构造函数和每个属性的set方法。值得注意的是，属性注入仅要求有set方法，并不要求真的有这个属性。当然我们还是习惯性地按照约定俗成的办法设置属性。

```java
public class Car{
    private String brand;
    private String color;
    private int maxSpeed;
	
    public void setBrand(String brand) {
        System.out.println("Setter of brand");
        this.brand = brand;
    }

    public void setColor(String color) {
        System.out.println("Setter of color");
        this.color = color;
    }

    public void setMaxSpeed(int maxSpeed) {
        System.out.println("Setter of maxSpeed");
        this.maxSpeed = maxSpeed;
    }
}

```

```xml
    <bean id="car" class="com.demo11.Car"
    p:brand="HongQi"
    p:color="black"
    p:maxSpeed="188"
    scope="singleton"/>
```

很好玩的一个规定：“变量的前两个字母要么全部大写，要么全部小写”

### 3.2 构造函数注入

构造函数注入bean要求bean必须要有带参数的构造函数。

#### 3.2.1 类型匹配入参

```xml
<bean id="car" class="com.baobaotao.car">
	<construct-arg type="java.lang.String">
		红旗
	</construct-arg>
	<construct-arg type="double">
		100
	</construct-arg>
</bean>
```

在初始化这个bean的时候，红旗和100将作为bean的构造函数的String类型参数和double类型参数入参

如果有两个重载的构造函数类型参数都一样的话，这个办法会出问题

#### 3.2.2 索引匹配入参

```xml
<bean id="car" class="com.baobaotao.car">
	<construct-arg index="0">
		红旗
	</construct-arg>
	<construct-arg index="1">
		100
	</construct-arg>
</bean>
```

在初始化这个bean的时候，红旗和100将作为bean的构造函数的第一个和第二个参数入参 

如果出现重载的构造函数的话，这个办法会出现问题。

#### 3.2.3 联合使用类型匹配和索引匹配

```xml
<bean id="car" class="com.baobaotao.car">
	<construct-arg index="0" type="java.lang.String">
		红旗
	</construct-arg>
	<construct-arg index="1" type="double">
		100
	</construct-arg>
</bean>
```

推荐使用

值得注意的是，使用构造函数注入会出现循环依赖而导致死锁，这个时候把其中一个改成属性注入即可。

### 3.3 工厂方法注入

在开发一个全新的app时，不推荐使用工厂方法注入，因为Spring已经实现好了很多工厂方法。但是如果要修改原有项目，可能还需要用工厂方法。

## 4. 注入参数详解

### 4.1 字面值

可以用字符串表示的值，一般就是基础数据类型和`java.lang.String`

值得注意的是，Spring不会忽略\<value\>\</value\>中间的空格符号

### 4.2 引用其他bean

ref元素可以引用其他bean，主要有下面三种

- bean：通过该属性可以引用同一个容器或者父容器中的bean
- local：仅能使用同一份配置文件中的bean
- parent：表明使用的是父容器中的bean

### 4.3 内部bean

如果一个bean仅被一个bean引用，可以写成内部bean的形式，有点像结构体。

```xml
<bean id="boss" class="com.baobaotao.Boss">
<property>
  <bean class="com.baobaotao.car">
		<property name="color" value="red">
  </bean>
</property>
</bean>
```

内部bean的id和scope会被忽略

### 4.4 null值

`<property name="brand"><null/></property>`可以为brand属性设置null值

### 4.5 级联属性

`<property name="car.brand" value="红旗">`可以直接为`Boss`类的`car`属性注入`brand`属性。

### 4.6 集合类型属性

> Test->demo12

### 4.7 简化配置

可以使用p命名空间简化大部分配置

### 4.8 自动装配

Spring容器可以通过Java反射机制获得bean实现类的结构信息，Spring可以按照某些规则进行Bean的自动装配，从而不用我们显式地配置。

不推荐使用

## 5. 方法注入

感觉不会用到啊，用到再说吧。

## 6. bean之间关系

### 6.1 继承

> Test->demo13

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="abstractCar" class="com.demo13.Car"
          p:brand="红旗"
          p:maxSpeed="200"
          p:color="RED"
          abstract="true"/>
    <bean id="car1" parent="abstractCar"
          p:color="BLACK"/>
    <bean id="car2" parent="abstractCar"
          p:color="WHITE"/>
</beans>
```

注意其实这里所谓的继承只是bean之间的继承并没有真实的类之间的继承。

### 6.2 依赖

除了ref元素声明的显式依赖之外，，可能出现的情况是，某个对象并不持有另一个对象的实例，但是依然要在另一个对象实例化之后才能实例化，这时可以使用`depends-on`元素

### 6.3 引用

可以提前知道错误，好像没有什么用处。

## 7.  整合多个配置文件

大型应用可能有很多配置文件。例如在bean1.xml中已经配置了了car1和car2，在bean2.xml中使用

```xml
<import resource="classpath:bean1.xml"/>
```

可以引用bean1.xml中的内容，这样应用只需要引用bean2.xml容器就可以使用car1和car2了。

一般来说，大型应用分模块分配配置文件，在应用层面整合它们。

## 8. bean作用域

Bean作用域会对Bean的生命周期和创建方式产生深远的影响，在Spring3.x中，Bean的作用域有下面几种

| 类别            | 说明                                       |
| ------------- | ---------------------------------------- |
| singleton     | 在容器中仅存在一个Bean实例                          |
| prototype     | 每次从容器中调用Bean时，都返回一个新的实例                  |
| request       | 每次http请求会创建一个新的Bean，仅适用于WebApplicationContext环境 |
| session       | 同一个Http session共享一个Bean，仅适用于WebApplicationContext环境 |
| globalSession | 同一个全局session共享一个Bean，仅适用于WebApplication环境 |

除了以上预定义的Bean作用域之外，也可以自定义作用域。只要编写类实现`org.springframework.beans.factory.config.Scope`接口，再通过`BeanFactoryPostProsessor`注册自定义的Bean作用域即可。

### 8.1 singeton作用域

很常用的设计模式，也是Spring默认的作用域。Spring采用了特殊技术，使得即使拥有`connection`的dao类也能实现单例化，方便了我们的使用。

在默认情况下，Spring的ApplicationContext启动时，会实例化所有单例的Bean并保存在缓存池里面。

### 8.2 prototype作用域

prototype作用域的Bean在每次get的时候都会新实例化一个对象。Spring容器在把Bean实例好交还给调用者之后，就不再管理其生命周期。

### 8.3 Web应用环境相关的Bean作用域

需要在web容器中进行配置监听器

#### 8.3.1 request作用域

request作用域的Bean对应一个http请求和生命周期，在request结束之后，这个Bean将被销毁。

```xml
<bean name="car" class="com.baobaotao.car" scope="request"/>
```

每次http请求调用car bean时，Spring容器创建一个新的car bean，并在请求处理完毕之后，销毁这个Bean。

#### 8.3.2 session作用域

session作用域的Bean横跨整个Http Session，Session中的左右请求都共享一个Bean。

#### 8.3.2 globalSession作用域

类似于Session作用域，仅在Portlet的web应用中使用。

## 9. FactoryBean

> Test->demo11	

一般情况下，Spring都是通过class的反射机制来实例Bean的，但是实际上也可以通过工厂化方法实现。只要Bean的实现类注册接口`FactoryBean`，在`getBean`时就会自动找到Bean中的`getObject`方法返回实例

```java
package com.demo14;

import org.springframework.beans.factory.FactoryBean;

/**
 * Created by Tondiyee on 2017/2/7.
 */
public class CarFactory implements FactoryBean<Car> {
    private String carInfo;

    public String getCarInfo() {
        return carInfo;
    }

    public void setCarInfo(String carInfo) {
        this.carInfo = carInfo;
    }

    public Car getObject() throws Exception {
        Car car = new Car();
        String[] temp=carInfo.split(",");
        car.setBrand(temp[0]);
        car.setColor(temp[1]);
        car.setMaxSpeed(Integer.parseInt(temp[2]));
        return car;
    }

    public Class<Car> getObjectType() {
        return Car.class;
    }

    public boolean isSingleton() {
        return false;
    }
}
```

## 10. 基于注释的配置

> 这波很关键啊

## 11. 基于Java类的配置

不推荐使用

小结：一般情况下，采用XML配置`DataSource,SessionFactory`等资源Bean，在XML中利用aop，context等命名空间进行相关主题的配置。其他项目中开发的Bean，采用注解配置。