## 设计模式-可复用的面向对象软件基础

---

### 本书引语

这本书并不是一本面向对象技术或设计的介绍用书，很多其他的书在这方面都做的很好。这本书假设你已经熟练地掌握了至少一门面向对象语言，并且你已经参与设计或实现一些面向对象的项目。在我们提及类似*“类，多态，接口，实现，继承”*之类的比较专业的词汇时，你应该对它们比较熟悉而不是还需要去翻阅词典。

当然，这本书也不是一本专业的技术著作。这是一本关于**设计模式**的书，它描述了一些简单且优雅的规则，这些规则被用于解决面向对象设计中的特定问题，并且被发展演化了很长时间，因此它们已经不是最初被设计出来的 样子了。软件设计者在努力提升他们产品的可复用性和灵活性时重新设计编码了原有的设计模式。现在，设计模式是一种简洁，易于使用的形式。

设计模式中可以不需要任何特定语言的支持，也不需要那些可以向你的朋友或领导吹嘘的编码窍门。任何一门标准的设计语言都可以用来表达设计模式，尽管应用设计模式可能比那些量身定做的解决方案要多费很多事，但是相信我，这些额外的工作将大大提升你项目的复用性和灵活性。

当你理解了这些设计模式，并且成功地（而不是云里雾里地）应用它们完成了一个项目时，你对面向对象设计将会有一个新的认识。你将会对灵活性，模块化，复用性，可理解性有一层更深的见解—这也是你选择面向对象设计的原因，不是吗？

这本书已经酝酿了很久。它的作者来自四个国家，它见证了三个作者的甜蜜婚姻和两个孩子的出生。许多人都曾经参与其中，我们将由其感谢*Bruce Anderson, Kent Beck*和*André Weinand*的建议和构想。我们也很感谢那些审阅了本书草稿的人，包括*Roger Bielefeld, Grady Booch, Tom Cargill, Marshall Cline, Ralph Hyre,Brian Kernighan,Thomas Laliberty, Mark Lorenz, Arthur Riel, Doug Schmidt, Clovis Tondo, Steve Vinoski*和*Rebecca Wirfs-Brock*。我们也很感谢*Addison-Wesley*队伍成员的帮助和他们的耐心，他们是*Kate Habib, Tiffany Moore, Lisa Raffaele, Pradeepa Siva*以及*John Wait*。尤其感谢IBM调查组的*Carl Kessler, Danny Sabbah* 和*Mark Wegman*的帮助。

最后，我们很感谢来自因特网的各位专家，他们帮助完成了本书的uml用图，鼓励我们创作并告诉我们我们所做的一切都是值得的。这些人包括且不限于以下：*Jon Avotins, SteveBerczuk, Julian Berdych, Matthias Bohlen, John Brant, Allan Clarke, Paul Chisholm, JensColdewey, Dave Collins, Jim Coplien, Don Dwiggins, Gabriele Elia, Doug Felt, Brian Foote,Denis Fortin, Ward Harold, Hermann Hueni, Nayeem Islam, Bikramjit Kalra, Paul Keefer,Thomas Kofler, Doug Lea, Dan LaLiberte, James Long, Ann Louise Luu, Pundi Madhavan,Brian Marick, Robert Martin, Dave McComb, CarlMcConnell, Christine Mingins, Hanspeter Mössenböck, Eric Newton, Marianne Ozkan, Roxsan Payette, Larry Podmolik, George Radin, Sita Ramakrishnan, Russ Ramirez, Alexander Ran, Dirk Riehle, Bryan Rosenburg,Aamod Sane, Duri Schmidt, Robert Seidl, Xin Shu, and Bill Walker*。

我们并不认为这是一本已经严谨且完整的书，它更像是我们几个目前思想或设计理念的结晶。我们欢迎任何对本书的评论和指点，无论是批评还是指正，或是指出我们的遗漏之处。你可以发送电子邮件至designpatterns@cs.uiuc.edu。你也可以通过发送邮件*send design pattern source*到design-patternssource@cs.uiuc.edu来获取本书例子中用到的源代码。现在，本书也有了配套的网站http://stwww.cs.uiuc.edu/users/patterns/DPBook/DPBook.html用来获取最新的消息和更新。

*Mountain View, California, E.G.*
*Montreal, Quebec, R.H.*
*Urbana, Illinois, R.J.*
*Hawthorne, New York, J.V.*

1994年8月

------

### 关于作者

本书的作者是软件开发领域权威的专家。*Dr.Erich Gamma*是苏黎世大学软件研究中心的技术指导；*Dr. Richard Helm*是IBM悉尼面向对象研究小组的一名成员；*Dr. Ralph Johnson*是伊利诺伊大学计算机技术中心的一名全能教员；*Dr. John Vlissides*在纽约的IBM研究中心工作

------

### 读者指南

这本书有两个主要的部分。第一部分（第一章和第二章）描述了什么是设计模式以及设计模式是如何帮助我们设计面向对象软件。它包含了一个设计案例的学习，这个案例向我们演示了，在现实中，设计模式怎样被使用。第二部分（三四五章）是设计模式清单的详细描述。

这份清单构成了本书的主要成分。这份清单将所有的设计模式分成三种，分别是**构建时，结构化，行为化**。你可以通过不同的方式来使用清单：你可以从头至尾通读，也可以仅仅快速浏览某个模式。另外一种方式是阅读整个章节，这样你将会明白模式与模式之间的联系。

你可以利用两个模式之间的提示作为通读整个清单的思维脉络。这种阅读方式将会告诉你，模式之间是怎样联系的，两个模式是怎样融合的，某个模式是怎样和另外的模式共同使用的。1.1节将用图形化的方式来描述整个提示。

另外一种阅读方式将会更加的时效性，你可以完全按照问题驱动的方式来阅读。跳跃到1.6节，它会告诉你在面向对象设计过程中的常见问题，和你的问题比照之后，你可以选择性地阅读某个模式。有些人第一次阅读时通篇阅读了整本书，第二次开始使用问题驱动的方式，我们觉得这样也很不错。

如果你并不是一个经验丰富的面向对象设计师，你可以仅仅阅读以下几个最重要，最常见，也是最简单的模式。

- **抽象工厂模式**
- **适配器模式**
- **组合模式**
- **装饰者模式**
- **工厂模式**
- **观察者模式**
- **策略模式**
- **模板方法模式**

几乎所有的面向对象系统中都或多或少地使用了这些模式中的某几种，有些复杂的系统甚至使用了以上的所有模式。这些模式将会帮助你从大体上理解设计模式和面向对象设计原则。

---

### 介绍

面向对象的设计是困难的，设计良好的**可复用**的面向对象软件更是难上加难。你必须要找到相关的对象，并把它们以合适的粒度抽象为类，定义好类之间的接口和类的继承层次，然后建立类与类之间的关键联系。你的设计必须既要精确到解决现在存在的问题，又要宽泛到为将来可能出现的问题和需求做好准备。你还想避免重新设计，或者说把重新设计的规模降到最低。一个经验丰富的面向对象设计师会告诉你，第一次就设计出“恰好符合要求的”可复用的，灵活的软件是几乎不可能的，他们通常会反复使用一个设计，在使用的过程中反复修改完善这个设计。

一方面，经验丰富的设计人员可以设计出很好的面向对象软件，另一方面，新手设计师可能会被数目繁杂的面向对象设计选择击败，并重新回到他们熟悉的路上-非面向对象设计。新手设计师要花费很多时间去学习面向对象设计。显然，老手们知道一些新手们不知道的东西。它是什么？

专家级程序员知道，不能总是通过原始的规则来解决问题。相反，他们会重复利用他们之前使用过的方法。当他们发现了一个好的解决方案时，他们会一再使用。这样的经历促进了他们成为专家。因此，你在面向对象系统中会发现很多使用了统一模式的，大同小异的类和用于交流的对象。这些模式解决了特定的问题，使得面向对象软件更加灵活，优雅最后实现可复用。设计模式可以帮助设计者重用他们成功的设计，而程序员们只需要在以往的基础上添加很少的新的内容。一个熟悉这些设计模式的程序员可以利用他们做出快速设计，从而节省学习时间。

让我们来用类比法论证这个道理。小说家和剧作家从来不会从头开始设计他们的作品。相反，他们会遵循某种模式，例如“悲剧英雄模式”（就像哈姆雷特和麦克白）或者“浪漫小说模式”（就像数不清的爱情小说）。同样的，面向对象设计人员将会遵循某种模式，例如“使用对象表示状态”或者“装饰你的对象从而你可以任意的添加或删除某种特征”。一旦你了解了设计模式，你在设计时将会思如泉涌。

我们都知道设计经验的重要性。你在设计中可能已经经历过这种感觉：你曾经解决过类似的问题，但是你不知道什么时候解决的，也忘了怎么解决的。如果你还记得你解决类似问题的细节，你就能很方便地使用以往的方法来解决新的问题而不需要从头开始。然而，在记忆设计经验这方面，人们往往做得很差。

这本书的目的是以设计模式的方式来记录面向对象设计中的经验之谈。每一个设计模式都很好地解释了面向对象系统中一个重要的曾被重复使用的设计方案。我们的目标是以一种人们能够记住且灵活应用的方式，来记录设计经验。在本章的末尾，我们将会以表格的形式列出一些最重要的设计模式。

设计模式使得重复利用成功的设计方案和架构变得十分简单。如果新加入的设计者知道了系统的设计模式，那么他将会很容易的融入到系统开发中。当你想要你的系统可重用，易修改的时候，设计模式往往能帮助你做出抉择。设计模式甚至可以通过提供明确的类的规范和对象交互，以此改善现有的系统的文档以及维护工作。简单的说，设计模式会帮助一个设计者更快地获得正确的设计。

这本书中的设计模式没有一个是新的或者未被证实的。我们仅仅收录那些在不同系统中被反复使用的设计模式。这其中大部分的设计模式在本书之前从来没有任何的文档描述。	这些设计模式要么来源于面向对象的社区，要么是一些成功的面向对象设计中使用的“模式”—没有一个模式是很难学习的。所以尽管它们都不是新的，我们换了一种新的更容易被接受的组织形式：把它们组织成设计成具有一致格式的设计模式表格。

出于篇幅的考虑，这本书中的设计模式仅仅是那些大部分设计人员应该了解的设计模式。它并没有包含任何的高深内容，例如分布式系统或实时性系统；也没有包含任何应用专业领域的专有设计模式；也没有告诉你如何使用用户接口，怎么写设备驱动，或者怎么使用一个面向对象的数据库。这些任何领域内都有各自的设计模式，它们应该被写成另外的书。

---

### 设计模式是什么？

*Christopher Alexander*说，*“每个模式描述了一个在我们的环境中经常会出现的问题，然后描述了这些问题的解决方案的共同的核心，使用这个核心生成的解决方案可以解决类似问题一百万次”*。尽管*Alexander*说的是建筑学中的模式，他所说的也可以用来解释面向对象设计中的模式，只不过我们的解决方案是以对象和接口的形式表达的，并不是以墙或窗表达。但是，设计模式的核心，是在某个特定环境中的解决方案。

总的来说，一个设计模式有四个基本的要素。

1. **模式名称**：我们用一两个单词来描述我们遇到的问题，我们的解决方案以及最终的结果。命名一个设计模式很大程度上扩展了我们关于软件的词汇量。模式名称让我们在一个更高的抽象层次上进行设计。如果你了解一个设计模式的名称的话，你在和同事交谈，文档编写时会十分方便。在我们编写设计模式表格的时候，取一个好的名字是一个最为艰难的部分。
2. **问题描述**：它解释了我们何时需要使用这个模式。它解释了问题域的上下文情景。它可能描述了面向对象设计中一个特定的问题，例如如何用对象去表示算法；它有可能描述了一些不方便使用的类和对象。有时，问题也会描述在使用某个特定模式之前，你必须要达成的特定情况。
3. **解决方案**：它描述了我们设计的主要元素，元素与元素之间的关系，元素的职责，元素之间的合作。解决方案并不会描述一个特定的设计和实现，因为一个设计模式就像一个模板一样可以用在很多不同的情况下。相反的，设计模式提供了问题的抽象描述以及如何用元素（在我们的例子中，元素一般指类和对象）的组合和安排来解决问题。
4. **结果**：它是应用了这个设计模式之后的结果。尽管结果在我们描述设计往往不会提及，它们对于应用设计模式以及理解使用代价和使用的好处都是很重要的。结果主要设计时间和空间的开销，它们也可以解决语言和实现问题。在面向对象设计中，设计模式对系统灵活性，可扩展性，可移植性的影响可能会影响我们是否会重用这个设计模式。列出这些结果对你理解这个设计模式很有帮助。

当然，一个模式是不是典型的设计模式也是公说公有理婆说婆有理。可能对于一个人来说，这是一个设计模式而对另一个人来说并不是（可能只是另一人的一种编程习惯）。本书当中，我们集中精力应付那些在某个特定抽象层次上的设计模式。设计模式并不是教你怎么设计队列和哈希表以及如何复用它们，它们也不是十分复杂，模块齐备的应用。本书中的设计模式描述了用于交流的对象和类，这些类是为了解决上下文中某些一般的设计问题。

一个设计模式命名，抽象，定义了面向对象设计中一个典型的设计架构，并把它们加工到可以被复用的层次。设计模式描述了可能参与的类和实例，阐明了它们的角色和合作，以及它们的对系统承担的责任。每一个设计模式都专注于某个特定的设计问题，它说明了何时应该运用这个设计模式，从其他的设计约束来看是否应该运用这个设计模式以及应用设计模式之后的结果和利弊。既然我们必须要落地我们的设计模式，每个设计模式也提供了一些*c++*代码，有时会提供一些*Smalltalk*代码描述。

设计模式描述了面向对象的设计原则，它们来源于一些*c++*和*Smalltalk*代码中一些典型的解决方案。比起程序化语言*Pascal，C，Ada*和非主流的面向对象设计语言*CLOS，Dylan，Self*，这两种语言是主流的面向对象设计语言。我们选择它们的原因也是如此--日常工作中这两种语言被广泛应用，并且有很高的人气。

编程语言的选择是很重要的，因为这会影响到人们看待问题的视角。我们的模式里面假定了*Smalltalk/C++*级别的语言特性，这些特性决定了某个模式能否被简洁地实现。如果我们用其他的语言，我们可能需要添加诸如“继承”，“封装”，“多态”等设计模式。同样的，我们提出的某些模式可能被一些小众的面向对象设计语言直接支持，例如*CLOS*语法中有多重方法，那么访问者模式可能就不那么必要了。实际上，*Smalltalk*和*C++*之间已经有许多例子可以说明，相同的设计模式在不同的语言环境下，实现难度是不一样的。

### Smalltalk MVC中的设计模式

在Smalltalk-80中，MVC组合被用来设计用户接口。仔细理解MVC中的设计模式，会帮助你更好地理解“模式”是什么含义。

MVC中包含三个不同的组件。模型（Model）是指应用对象，视图（View）是指屏幕上的展示内容，控制器（Controller）定义了用户界面如何对人的输入做出反应。在MVC结构之前，用户接口的设计往往把这三块揉成一个臃肿的整体，而MVC结构将他们分离开，并且提升了可用性和灵活性。

MVC架构将视图和模型分开，在这两者之间添加一个“发布-订阅“协议层。视图必须要保证它的表现会被直接映射到模型的状态中。当模型的数据发生改变时，模型会发布一个消息，包含了这次改变的具体内容。订阅了该模型的视图可以依据这个消息来更新自己。这个方法使得你可以把多个展现不同场景的视图连接到同一个模型上，也可以根据模型自动创建一个新的视图而不是重新编写一个视图。

下面的图表示怎样由模型中三个基本的数据获得不同的视图（控制器暂时略过）。在这些视图中，有的视图是一个简单的表格，有的视图是柱形图，也有一个扇形图，这些视图从不同的角度阐述了这几个数据。当数据发生变化式，模型会直接通知视图，而视图也通过获得数据的方式与模型时刻交流着。

![image-20180913131904083](/Users/tangdaye/git-repos/notes/png/设计模式/1.png)

从表面上看，这个例子只是表示了一种将视图和模型解耦的设计方式。但是这种设计对于一个更普遍的问题也是适用的，那就是如何将一个对象与其他对象解耦，使得在不需要修改这个对象，使它了解其他对象详细信息的情况下，将自己的改变通知给其他对象？这个更普遍的问题被称为*观察者模式*。

MVC模式的另外一个特性是视图是可以嵌套的。例如，一个按钮的控制面板在实现上可能是由一个大的复杂的视图嵌套着一些按钮的视图来完成的，检查员的用户界面的某个视图可能在纠错员的用户界面中被复用。MVC结构允许开发人员编写视图的子视图，以此来实现嵌套视图。当需要用到视图的时候，你可以使用任何一个你已经实现的子视图来代替它。同样的，子视图也可以拥有自己的子视图。

同样的，我们也可以简单地认为这个设计想法只是为了解决了一个子视图嵌套的问题。但是实际上，有一个更加普遍的问题是，我们时常需要将一群对象组合起来形成一个新的独立的对象。*组合模式*允许人们建立一个类的等级制度，使得一个类可以拥有一些子类，用来定义一些从属的元素（例如按钮），作为子类，他们将被组合起来变成一个新的复杂类。

