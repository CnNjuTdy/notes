# 设计模式

---

## 本书引语

这本书并不是一本面向对象技术或设计的介绍用书，很多其他的书在这方面都做的很好。这本书假设你已经熟练地掌握了至少一门面向对象语言，并且你已经参与设计或实现一些面向对象的项目。在我们提及类似*“类，多态，接口，实现，继承”*之类的比较专业的词汇时，你应该对它们比较熟悉而不是还需要去翻阅词典。

当然，这本书也不是一本专业的技术著作。这是一本关于**设计模式**的书，它描述了一些简单且优雅的规则，这些规则被用于解决面向对象设计中的特定问题，并且被发展演化了很长时间，因此它们已经不是最初被设计出来的 样子了。软件设计者在努力提升他们产品的可复用性和灵活性时重新设计编码了原有的设计模式。现在，设计模式是一种简洁，易于使用的形式。

设计模式中可以不需要任何特定语言的支持，也不需要那些可以向你的朋友或领导吹嘘的编码窍门。任何一门标准的设计语言都可以用来表达设计模式，尽管应用设计模式可能比那些量身定做的解决方案要多费很多事，但是相信我，这些额外的工作将大大提升你项目的复用性和灵活性。

当你理解了这些设计模式，并且成功地（而不是云里雾里地）应用它们完成了一个项目时，你对面向对象设计将会有一个新的认识。你将会对灵活性，模块化，复用性，可理解性有一层更深的见解—这也是你选择面向对象设计的原因，不是吗？

这本书已经酝酿了很久。它的作者来自四个国家，它见证了三个作者的甜蜜婚姻和两个孩子的出生。许多人都曾经参与其中，我们将由其感谢*Bruce Anderson, Kent Beck*和*André Weinand*的建议和构想。我们也很感谢那些审阅了本书草稿的人，包括*Roger Bielefeld, Grady Booch, Tom Cargill, Marshall Cline, Ralph Hyre,Brian Kernighan,Thomas Laliberty, Mark Lorenz, Arthur Riel, Doug Schmidt, Clovis Tondo, Steve Vinoski*和*Rebecca Wirfs-Brock*。我们也很感谢*Addison-Wesley*队伍成员的帮助和他们的耐心，他们是*Kate Habib, Tiffany Moore, Lisa Raffaele, Pradeepa Siva*以及*John Wait*。尤其感谢IBM调查组的*Carl Kessler, Danny Sabbah* 和*Mark Wegman*的帮助。

最后，我们很感谢来自因特网的各位专家，他们帮助完成了本书的uml用图，鼓励我们创作并告诉我们我们所做的一切都是值得的。这些人包括且不限于以下：*Jon Avotins, SteveBerczuk, Julian Berdych, Matthias Bohlen, John Brant, Allan Clarke, Paul Chisholm, JensColdewey, Dave Collins, Jim Coplien, Don Dwiggins, Gabriele Elia, Doug Felt, Brian Foote,Denis Fortin, Ward Harold, Hermann Hueni, Nayeem Islam, Bikramjit Kalra, Paul Keefer,Thomas Kofler, Doug Lea, Dan LaLiberte, James Long, Ann Louise Luu, Pundi Madhavan,Brian Marick, Robert Martin, Dave McComb, CarlMcConnell, Christine Mingins, Hanspeter Mössenböck, Eric Newton, Marianne Ozkan, Roxsan Payette, Larry Podmolik, George Radin, Sita Ramakrishnan, Russ Ramirez, Alexander Ran, Dirk Riehle, Bryan Rosenburg,Aamod Sane, Duri Schmidt, Robert Seidl, Xin Shu, and Bill Walker*。

我们并不认为这是一本已经严谨且完整的书，它更像是我们几个目前思想或设计理念的结晶。我们欢迎任何对本书的评论和指点，无论是批评还是指正，或是指出我们的遗漏之处。你可以发送电子邮件至designpatterns@cs.uiuc.edu。你也可以通过发送邮件*send design pattern source*到design-patternssource@cs.uiuc.edu来获取本书例子中用到的源代码。现在，本书也有了配套的网站http://stwww.cs.uiuc.edu/users/patterns/DPBook/DPBook.html用来获取最新的消息和更新。

*Mountain View, California, E.G.*
*Montreal, Quebec, R.H.*
*Urbana, Illinois, R.J.*
*Hawthorne, New York, J.V.*

1994年8月

------

## 关于作者

本书的作者是软件开发领域权威的专家。*Dr.Erich Gamma*是苏黎世大学软件研究中心的技术指导；*Dr. Richard Helm*是IBM悉尼面向对象研究小组的一名成员；*Dr. Ralph Johnson*是伊利诺伊大学计算机技术中心的一名全能教员；*Dr. John Vlissides*在纽约的IBM研究中心工作

------

## 读者指南

这本书有两个主要的部分。第一部分（第一章和第二章）描述了什么是设计模式以及设计模式是如何帮助我们设计面向对象软件。它包含了一个设计案例的学习，这个案例向我们演示了，在现实中，设计模式怎样被使用。第二部分（三四五章）是设计模式清单的详细描述。

这份清单构成了本书的主要成分。这份清单将所有的设计模式分成三种，分别是**构建时，结构化，行为化**。你可以通过不同的方式来使用清单：你可以从头至尾通读，也可以仅仅快速浏览某个模式。另外一种方式是阅读整个章节，这样你将会明白模式与模式之间的联系。

你可以利用两个模式之间的提示作为通读整个清单的思维脉络。这种阅读方式将会告诉你，模式之间是怎样联系的，两个模式是怎样融合的，某个模式是怎样和另外的模式共同使用的。1.1节将用图形化的方式来描述整个提示。

另外一种阅读方式将会更加的时效性，你可以完全按照问题驱动的方式来阅读。跳跃到1.6节，它会告诉你在面向对象设计过程中的常见问题，和你的问题比照之后，你可以选择性地阅读某个模式。有些人第一次阅读时通篇阅读了整本书，第二次开始使用问题驱动的方式，我们觉得这样也很不错。

如果你并不是一个经验丰富的面向对象设计师，你可以仅仅阅读以下几个最重要，最常见，也是最简单的模式。

- 抽象工厂模式
- 适配器模式
- 组合模式
- 装饰者模式
- 工厂模式
- 观察者模式
- 策略模式
- 模板方法模式

几乎所有的面向对象系统中都或多或少地使用了这些模式中的某几种，有些复杂的系统甚至使用了以上的所有模式。这些模式将会帮助你从大体上理解设计模式和面向对象设计原则。

---

## 第一章 介绍

面向对象的设计是困难的，设计良好的**可复用**的面向对象软件更是难上加难。你必须要找到相关的对象，并把它们以合适的粒度抽象为类，定义好类之间的接口和类的继承层次，然后建立类与类之间的关键联系。你的设计必须既要精确到解决现在存在的问题，又要宽泛到为将来可能出现的问题和需求做好准备。你还想避免重新设计，或者说把重新设计的规模降到最低。一个经验丰富的面向对象设计师会告诉你，第一次就设计出“恰好符合要求的”可复用的，灵活的软件是几乎不可能的，他们通常会反复使用一个设计，在使用的过程中反复修改完善这个设计。

一方面，经验丰富的设计人员可以设计出很好的面向对象软件，另一方面，新手设计师可能会被数目繁杂的面向对象设计选择击败，并重新回到他们熟悉的路上-非面向对象设计。新手设计师要花费很多时间去学习面向对象设计。显然，老手们知道一些新手们不知道的东西。它是什么？

专家级程序员知道，不能总是通过原始的规则来解决问题。相反，他们会重复利用他们之前使用过的方法。当他们发现了一个好的解决方案时，他们会一再使用。这样的经历促进了他们成为专家。因此，你在面向对象系统中会发现很多使用了统一模式的，大同小异的类和用于交流的对象。这些模式解决了特定的问题，使得面向对象软件更加灵活，优雅最后实现可复用。设计模式可以帮助设计者重用他们成功的设计，而程序员们只需要在以往的基础上添加很少的新的内容。一个熟悉这些设计模式的程序员可以利用他们做出快速设计，从而节省学习时间。

让我们来用类比法论证这个道理。小说家和剧作家从来不会从头开始设计他们的作品。相反，他们会遵循某种模式，例如“悲剧英雄模式”（就像哈姆雷特和麦克白）或者“浪漫小说模式”（就像数不清的爱情小说）。同样的，面向对象设计人员将会遵循某种模式，例如“使用对象表示状态”或者“装饰你的对象从而你可以任意的添加或删除某种特征”。一旦你了解了设计模式，你在设计时将会思如泉涌。

我们都知道设计经验的重要性。你在设计中可能已经经历过这种感觉：你曾经解决过类似的问题，但是你不知道什么时候解决的，也忘了怎么解决的。如果你还记得你解决类似问题的细节，你就能很方便地使用以往的方法来解决新的问题而不需要从头开始。然而，在记忆设计经验这方面，人们往往做得很差。

这本书的目的是以设计模式的方式来记录面向对象设计中的经验之谈。每一个设计模式都很好地解释了面向对象系统中一个重要的曾被重复使用的设计方案。我们的目标是以一种人们能够记住且灵活应用的方式，来记录设计经验。在本章的末尾，我们将会以表格的形式列出一些最重要的设计模式。

设计模式使得重复利用成功的设计方案和架构变得十分简单。如果新加入的设计者知道了系统的设计模式，那么他将会很容易的融入到系统开发中。当你想要你的系统可重用，易修改的时候，设计模式往往能帮助你做出抉择。设计模式甚至可以通过提供明确的类的规范和对象交互，以此改善现有的系统的文档以及维护工作。简单的说，设计模式会帮助一个设计者更快地获得正确的设计。

这本书中的设计模式没有一个是新的或者未被证实的。我们仅仅收录那些在不同系统中被反复使用的设计模式。这其中大部分的设计模式在本书之前从来没有任何的文档描述。	这些设计模式要么来源于面向对象的社区，要么是一些成功的面向对象设计中使用的“模式”—没有一个模式是很难学习的。所以尽管它们都不是新的，我们换了一种新的更容易被接受的组织形式：把它们组织成设计成具有一致格式的设计模式表格。

出于篇幅的考虑，这本书中的设计模式仅仅是那些大部分设计人员应该了解的设计模式。它并没有包含任何的高深内容，例如分布式系统或实时性系统；也没有包含任何应用专业领域的专有设计模式；也没有告诉你如何使用用户接口，怎么写设备驱动，或者怎么使用一个面向对象的数据库。这些任何领域内都有各自的设计模式，它们应该被写成另外的书。

### 设计模式是什么？

*Christopher Alexander*说，*“每个模式描述了一个在我们的环境中经常会出现的问题，然后描述了这些问题的解决方案的共同的核心，使用这个核心生成的解决方案可以解决类似问题一百万次”*。尽管*Alexander*说的是建筑学中的模式，他所说的也可以用来解释面向对象设计中的模式，只不过我们的解决方案是以对象和接口的形式表达的，并不是以墙或窗表达。但是，设计模式的核心，是在某个特定环境中的解决方案。

总的来说，一个设计模式有四个基本的要素。

1. **模式名称**：我们用一两个单词来描述我们遇到的问题，我们的解决方案以及最终的结果。命名一个设计模式很大程度上扩展了我们关于软件的词汇量。模式名称让我们在一个更高的抽象层次上进行设计。如果你了解一个设计模式的名称的话，你在和同事交谈，文档编写时会十分方便。在我们编写设计模式表格的时候，取一个好的名字是一个最为艰难的部分。
2. **问题描述**：它解释了我们何时需要使用这个模式。它解释了问题域的上下文情景。它可能描述了面向对象设计中一个特定的问题，例如如何用对象去表示算法；它有可能描述了一些不方便使用的类和对象。有时，问题也会描述在使用某个特定模式之前，你必须要达成的特定情况。
3. **解决方案**：它描述了我们设计的主要元素，元素与元素之间的关系，元素的职责，元素之间的合作。解决方案并不会描述一个特定的设计和实现，因为一个设计模式就像一个模板一样可以用在很多不同的情况下。相反的，设计模式提供了问题的抽象描述以及如何用元素（在我们的例子中，元素一般指类和对象）的组合和安排来解决问题。
4. **结果**：它是应用了这个设计模式之后的结果。尽管结果在我们描述设计往往不会提及，它们对于应用设计模式以及理解使用代价和使用的好处都是很重要的。结果主要设计时间和空间的开销，它们也可以解决语言和实现问题。在面向对象设计中，设计模式对系统灵活性，可扩展性，可移植性的影响可能会影响我们是否会重用这个设计模式。列出这些结果对你理解这个设计模式很有帮助。

当然，一个模式是不是典型的设计模式也是公说公有理婆说婆有理。可能对于一个人来说，这是一个设计模式而对另一个人来说并不是（可能只是另一人的一种编程习惯）。本书当中，我们集中精力应付那些在某个特定抽象层次上的设计模式。设计模式并不是教你怎么设计队列和哈希表以及如何复用它们，它们也不是十分复杂，模块齐备的应用。本书中的设计模式描述了用于交流的对象和类，这些类是为了解决上下文中某些一般的设计问题。

一个设计模式命名，抽象，定义了面向对象设计中一个典型的设计架构，并把它们加工到可以被复用的层次。设计模式描述了可能参与的类和实例，阐明了它们的角色和合作，以及它们的对系统承担的责任。每一个设计模式都专注于某个特定的设计问题，它说明了何时应该运用这个设计模式，从其他的设计约束来看是否应该运用这个设计模式以及应用设计模式之后的结果和利弊。既然我们必须要落地我们的设计模式，每个设计模式也提供了一些*c++*代码，有时会提供一些*Smalltalk*代码描述。

设计模式描述了面向对象的设计原则，它们来源于一些*c++*和*Smalltalk*代码中一些典型的解决方案。比起程序化语言*Pascal，C，Ada*和非主流的面向对象设计语言*CLOS，Dylan，Self*，这两种语言是主流的面向对象设计语言。我们选择它们的原因也是如此--日常工作中这两种语言被广泛应用，并且有很高的人气。

编程语言的选择是很重要的，因为这会影响到人们看待问题的视角。我们的模式里面假定了*Smalltalk/C++*级别的语言特性，这些特性决定了某个模式能否被简洁地实现。如果我们用其他的语言，我们可能需要添加诸如“继承”，“封装”，“多态”等设计模式。同样的，我们提出的某些模式可能被一些小众的面向对象设计语言直接支持，例如*CLOS*语法中有多重方法，那么访问者模式可能就不那么必要了。实际上，*Smalltalk*和*C++*之间已经有许多例子可以说明，相同的设计模式在不同的语言环境下，实现难度是不一样的。

### MVC中的设计模式

在Smalltalk-80中，MVC组合被用来设计用户接口。仔细理解MVC中的设计模式，会帮助你更好地理解“模式”是什么含义。

MVC中包含三个不同的组件。模型（Model）是指应用对象，视图（View）是指屏幕上的展示内容，控制器（Controller）定义了用户界面如何对人的输入做出反应。在MVC结构之前，用户接口的设计往往把这三块揉成一个臃肿的整体，而MVC结构将他们分离开，并且提升了可用性和灵活性。

MVC架构将视图和模型分开，在这两者之间添加一个“发布-订阅“协议层。视图必须要保证它的表现会被直接映射到模型的状态中。当模型的数据发生改变时，模型会发布一个消息，包含了这次改变的具体内容。订阅了该模型的视图可以依据这个消息来更新自己。这个方法使得你可以把多个展现不同场景的视图连接到同一个模型上，也可以根据模型自动创建一个新的视图而不是重新编写一个视图。

下面的图1.1表示怎样由模型中三个基本的数据获得不同的视图（控制器暂时略过）。在这些视图中，有的视图是一个简单的表格，有的视图是柱形图，也有一个扇形图，这些视图从不同的角度阐述了这几个数据。当数据发生变化式，模型会直接通知视图，而视图也通过获得数据的方式与模型时刻交流着。

![1-1](/Users/tangdaye/git-repos/notes/png/设计模式/1/1.png)

*图1.1 model和view之间的关系*

从表面上看，这个例子只是表示了一种将视图和模型解耦的设计方式。但是这种设计对于一个更普遍的问题也是适用的，那就是如何将一个对象与其他对象解耦，使得在不需要修改这个对象，使它了解其他对象详细信息的情况下，将自己的改变通知给其他对象？这个更普遍的问题被称为*观察者模式*。

MVC模式的另外一个特性是视图是可以嵌套的。例如，一个按钮的控制面板在实现上可能是由一个大的复杂的视图嵌套着一些按钮的视图来完成的，检查员的用户界面的某个视图可能在纠错员的用户界面中被复用。MVC结构允许开发人员编写视图的子视图，以此来实现嵌套视图。当需要用到视图的时候，你可以使用任何一个你已经实现的子视图来代替它。同样的，子视图也可以拥有自己的子视图。

同样的，我们也可以简单地认为这个设计想法只是为了解决了一个子视图嵌套的问题。但是实际上，有一个更加普遍的问题是，我们时常需要将一群对象组合起来形成一个新的独立的对象。*组合模式*允许人们建立一个类的等级制度，使得一个类可以拥有一些子类，用来定义一些从属的元素（例如按钮），作为子类，他们将被组合起来变成一个新的复杂类。

此外，MVC结构允许你在不改变视图的情况下，修改人们与用户界面交互的方式。你可能想要修改系统对键盘的相应方式，或者想要添加一个弹出框而不是键盘指令。MVC将界面相应概括在控制器组件中，同样的，控制器组件是有层次的，这意味着你可以很轻松地建立一个子控制器。

视图会对应一个控制器的子类来实现一种特定的相应策略。当你需要实现不同的相应策略时，只需要简单地更换一下控制器的实例就可以做到了。你甚至可以基于用户输入，在运行时修改视图对应的控制器。例如，只要它对应的控制器忽略掉所有用户输入，一个视图可以拒绝一切输入。

视图和控制器的关系是*策略模式*的一个具体的例子。一个策略是一个算法对象，当你想要动态地替换算法时或者有很多算法规则或者有些你想要复用的复杂数据结构时，策略模式是一个很不错的想法。

MVC也用了许多其他的设计模式，比如视图对象会应用*工厂方法*来自己选择特定的控制器，视图使用*装饰者模式*来添加一个滚动器。不过总得来说，MVC主要使用的是*观察者模式，组合模式，策略模式*

### 描述一个设计模式

如何描述一个设计模式？图形的标记很有用，而且很好用，但是光有图形是不够的。图形只能简单地用对象和类以及他们之间的关系描述出设计过程的最终结果。为了复用这个设计，我们需要记录决策过程，替代方案以及使用了这种设计之后带了的利弊权衡。具体的例子也是很有必要的，因为具体的例子可以帮助你看到这个设计的实际效果。

我们使用一种固定的格式来描述设计模式。对于每一个设计模式，我们用下面模板中给出的格式来描述。这个模板为设计模式设计了一个“模式”，使得设计模式更加容易学习，比较和使用。

- 名称和类别。设计模式的名称是整个模式的精髓所在，它将要成为你的设计词汇的一部分，因此一个好的名称是十分重要的。设计模式的类别会在1.5节相关内容中介绍。
- 意图。用一句话回答了以下问题：设计模式做了什么事？它要根本目的是什么？它需要解决哪些特定的问题？
- 别名。如果有的话，给出这个设计模式经常用的别名。
- 设计动机。一个说明了设计问题以及模式中的类时如何解决设计问题的场景。场景将会帮助你更好地理解设计模式额外的抽象内容
- 适用范围。这个设计模式在什么情况下可以被使用？这个设计模式致力于解决什么样的设计问题？你要如何识别你是否遇到了这些问题？
- 架构。架构将会使用OMT记号（Object Modeling Technique，对象建模技术）来绘制出设计模式的架构。我们也会使用一种交互图来说明对象之间的调用与合作。附录B详细得说明了这些记号。
- 参与者。这个设计模式中参与的对象和类。
- 参与者之间的关系。参与其中的对象和类是如何担任他们的职责的。
- 结果。这个设计模式是如何支持它的面向对象性质的？使用了这个设计模式的优缺点在哪？你改变了系统架构的哪一个部分？
- 实现。在你实现这个模式的，有哪些陷阱，技巧或者技术你是应该知晓的？有没有语言级别的特殊情况要注意？
- 示例代码。用*c++*或者*Smalltalk*实现的代码框架的。
- 著名的使用范例。在现实的系统中这个模式的真实的例子，我们至少会在两个领域中举出例子。
- 相关模式。有哪些设计模式和这个设计模式是紧密相关的？他们两者之间主要的区别是什么？这个问题应该用哪一个设计模式？

附录的信息将会帮助你更好地理解设计模式以及围绕设计模式之间的讨论。附录A是本书中使用的所有术语表。在此前我们已经提到附录B，它详细说明了本书使用的建模记号。在此后的一些内容里，我们也会稍微介绍一些建模记号的内容。最后在附录C中，给出了本书中所有示例的源代码。

### 设计模式清单

下面的清单中列出了23种设计模式，他们的名称和意图会列在下表中给你一个总体上的了解。设计模式名称后面圆括号里的内容是这个设计模式在本书中的序号（本书中讲述设计模式的顺序）。

- *抽象工厂模式*。抽象工厂提供了一个在无需特定指明具体类的情况下创建一系列相关对象的方案。
- *适配器模式*。适配器模式将一个类的接口转化成了另一个访问者视角的接口。适配器模式允许不同的类一起工作，否则他们会因为互相冲突的接口而不能共存。
- *桥接模式*。桥接模式把一个抽象概念和它具体的实现解耦以便两者可以独立使用。
- *建造者模式*。对于一个比较复杂的对象，建造者模式单独提供了对象的建成方案，从而使得相同的建造过程可以创建不同的对象。
- *负责链模式*。通过给予不同的类处理请求的方式来避免请求发送者与信息接收者之间的耦合，消息会一直在链条上传递直到有一个类过来处理了它。
- *命令模式*。这个模式把一个消息看成一个对象，这样的话，你可以通过不同的请求，消息或者日志化的信息将不同的客户端参数化，并且提供可以撤销的操作。
- *组合模式*。将不同的对象组合成树形的结构来表示部分-整体体系。组合模式允许客户端统一地对待子类以及它们组合成的类。
- *装饰者模式*。讲一个额外的职责动态得添加到一个对象身上。装饰者模式为对象额外的功能提供了一个灵活的可替代的方案。
- *外观模式*。在子系统中为一系列的接口提供统一的访问接口。外观模式提供了一个更高级别的接口使得子系统使用起来更方便。
- *工厂方法*。工厂方法提供了一个创建对象的接口，与前面的抽象工厂不同的是，工厂方法让子类自己选择实例化哪个对象。工厂方法使得一个类自己定义子类的实例化方式。
- *享元模式*。享元模式允许不同的组件高效地共享很大量的数据。
- *解释器模式*。为某种语言，针对它的语法定义了一个展示层，并使用这个展示层定义了一个解释器，用于解释语言中的句子。
- *迭代器模式*。提供一种顺序访问聚合对象元素的方法，这种方法不会暴露聚合对象的基础结构。
- *中间人模式*。为一系列对象定义了一个描述他们交互方式的对象。代理模式通过组织对象之间的直接交互降低了这些对象之间的耦合程度，并且它能够让你分清他们各自的独立的交互模式。
- *备忘录模式*。在不违反封装原则的情况下，备忘录模式可以保存对象的内部状态，以便稍后可以照此恢复这个对象。
- *观察者模式*。在一些对象之间定义了一个一对多的依赖关系。当“一”的那个对象状态发生改变的时候，所有”多“的那个对象都可以自动得根据他们之间的依赖关系改变自己的状态。
- *原型模式*。使用预定义的原型来指定对象类型，并创建新的对象。
- *代理模式*。代理模式为一个对象提供了一个替代品或者说占位品以便其他对象使用这个对象。
- *单例模式*。保证一个类仅有一个实例化的对象，并且为它创建一个可以全局访问的接口。
- *状态模式*。允许一个对象在它的状态改变时改变它的行为模式，仿佛这个对象改变了这个类一样。
- *策略模式*。策略模式定义了一族算法，并使它们可以互相交换得被使用。策略模式使得其他程序可以更加独立地调用这些算法。
- *模板方法*。模板方法在父类中定义算法的骨架，并把一些详细的完善步骤推迟到子类中进行。模板方法允许子类重新定义算法的某些步骤而不改变算法的结构。
- *访问者模式*。访问者模式表示要对对象结构的元素执行的操作，它允许你定义新操作，而无需更改其操作的元素的类。

### 编排设计模式清单

设计模式从它们的粒度和抽象等级来看是不同的。由于设计模式种类繁多，我们需要想到一种办法来编排它们。在这一小节中我们将设计模式分了类，从而我们可以清晰得看出一个设计模式族以及它们的相关的设计模式。这种分类方式可以帮助你迅速地想学习设计模式清单，它也能够帮助你寻找一种新的设计模式。

我们会用两种方案来分类设计模式（表1.1中）。第一种分类方式是按照目的分类，即这种设计模式做了一件什么事。设计模式的目的包括**创建，结构，行为**，创建类型的设计模式关注对象的创建过程，结构类型的设计模式关注对象或类的组成模式，而行为类型的设计模式描述了类和对象的交互以及分发职责的方式。

| 目的 | 设计模式                                                     |
| ---- | ------------------------------------------------------------ |
| 创建 | **工厂方法**  抽象工厂模式  建造者模式  原型模式  单例模式   |
| 结构 | **适配器模式** 桥接模式 组合器模式 装饰器模式 外观模式 代理模式 |
| 行为 | **解释器模式 模板方法** 职责链模式 命令模式 迭代器模式 中间人模式 备忘录模式 观察者模式 状态模式 策略模式 访问者模式 |

*表1.1 设计模式的分类*

另一种对设计模式的分类方式是按照设计模式影响的范围进行分类。有些设计模式是基础得运用在了类上，也有的是运用在了对象上。类类型设计模式处理了类和子类之间的关系，这些关系是在运行前就被建立起来的，因此他们很稳固，在编译时给定。对象类型设计模式处理了对象之间的关系，它们是可以在运行时被动态改变的，因此更加灵活。几乎所有的模式都使用了继承来做一些功能扩展的工作，因此绝大部分设计模式是对象类型设计模式。表1.1中，加粗的设计模式是类类型设计模式。

创建-类类型的设计模式将对象创建的部分工作推迟到了子类之中进行，而创建-对象类型的设计模式将部分工作推迟到了其他的一些对象中。结构-类类型的设计模式使用继承来组合类，而创建-对象类型的设计模式描述了召集其他对象来组合的方法。行为-类类型的设计模式使用继承来描述算法和控制流，而行为-对象类型的设计模式描述了一群对象时如何完成一个对象独自无法完成的任务的。

除了以上两种方式之外，也有一些其他方式可以编排设计模式清单。有一些模式经常一起使用，例如组合模式经常和迭代器模式或访问者模式经常一起使用。有些模式是可以相互替换的，例如原型模式和抽象工厂模式经常替换。有些模式尽管目的不同，但是最后的设计结果是一样的，例如组合模式和装饰器模式最后的设计结果很像。

另一种编排设计模式的方式是根据设计模式是如何相互参考它们的”相关设计模式“的。图1.2 用图的形式描述了这种互相参考的关系。

![1-2](/Users/tangdaye/git-repos/notes/png/设计模式/1/2.png)

*图1.2 设计模式之间的参考关系*

鉴于有许多办法可以编排设计模式，用不同角度去思考设计模式将会加深你对设计模式做了什么，如何比较，何时使用这些问题的思考。

### 设计模式是如何解决设计问题的

#### 找到一个合适的对象

面向对象的程序由对象构成，对象是将数据和数据和数据的行为打包的实体。数据的行为通常被称为方法或是行动。当一个对象从客户端收到请求或是信息时，它会采取一定的行动。

请求是使对象执行操作的唯一方法。操作是更改对象内部数据的唯一方法。由于这些限制，对象私密化它的内部状态被称为封装。对象的内部状态不能直接访问，并且它的表示在对象外部是不可见的。

面向对象设计的难点在于将系统分解为对象。这项任务很困难，因为许多因素都会发挥作用：封装，粒度，依赖性，灵活性，性能，演化，可重用性等等。它们都会以相互冲突的方式影响我们对系统的分解。

面向对象设计有许多方法。你可以写出一张问题的描述清单，例如这个系统是要帮助谁做什么事情的，然后将它其中的名词和动词找出来，接着创建出对应的类和相应的操作。或者你也可以专注于系统元素的协作与职责。再或者，你可以对现实世界进行建模，并把你分析过程中遇到对象加入到设计中。对于哪个设计方法更好这个问题，不同的人总是有着不同的见解。

在面向对象设计过程中，许多对象都来自现实，但是也有一些类在现实世界里没有对应，例如数组，列表这些低级类，也有一些是高级一些的，但是也不在现实世界中。例如组合模式引入了一种抽象来单独处理现实生活中没有对应的类。严格得对应现实导致的问题是，系统可能现在很好使用也很容易理解，但是明天就没办法扩展了。在设计过程中，适度的抽象是灵活设计的关键。

设计模式可帮助你找到不太明显的抽象。 例如，表示过程或算法的对象本质上不会发生，但它们是灵活设计的关键部分， 策略模式描述了如何实现可互换的算法族，状态模式将实体的每个状态表示为对象。 在分析甚至设计的早期阶段很少发现这些对象; 它们是在一次又一次的实践中，由人们总结出的，使得系统更灵活，可重用的关键。

#### 确定对象粒度

对象的大小和数量可能有很大差异，大到代表整个硬件或是整个应用，小到仅表示一个菜单中的一个子选项。我们如何决定哪些东西可以成为一个对象呢？

设计模式也解决了这个问题。外观模式描述了如何把整个子系统写成一个对象，享元模式描述了如何以最精细的粒度支持大量的对象，而其他的设计模式描述了如何将特定的对象分解为较小的对象。抽象工厂模式和建造者模式用来生成对象，它们的唯一职责就是生成对象。访问者模式和命令模式的唯一职责是在一组对象上实现一个请求。

#### 定义对象的接口

对象给它声明的每个操作都指定了方法名，作为参数的对象以及方法的返回值，这被称为方法的函数签名。由对象的操作定义的所有函数签名集称为对象的接口。对象的接口表示所有可以发到这个对象的所有的请求集合。外部对象可以把任何与函数签名匹配的请求发送到对象。

类型是用于表示特定接口的名称。如果对象接受对类型为“窗口”的接口中定义的所有请求，则称对象称为具有“窗口”类型。对象可以具有许多类型，并且不同的对象可以共享类型。对象接口的一部分可能来自于它的某个类型，而另一些来自于它的其他类型，两个相同类型的对象只需要共享其接口的一部分。接口可以包含其他接口作为子集，如果一个类型的接口仅包含另一个类型的方法，那么它就是另一个类型的子类型，另一个类型就是该类型的超类型。

接口是面向对象系统的基础，只有通过接口才能了解对象。如果不知道对象的接口，我们没有办法获悉对象的任何信息，也没有办法对对象进行操作。对象的接口没有说明它的实现，因此不同的对象可以自由地以不同的方式实现请求，这也意味着具有完全不同实现的两个对象可以具有相同的接口。

当请求发送到对象时，执行的特定方法取决于请求和接收请求的对象。支持相同请求的不同对象可能具有满足这些请求的方法的不同实现。这种运行时的请求和处理请求的对象的绑定被称为动态绑定。

动态绑定意味着，知道运行时，你都无法获悉这个请求究竟是由哪个对象作出处理的，因为可以处理特定请求的对象有很多。因此，你可以编写一个接口来接受处理这个请求，并实现许多对象来实现这个接口。此外，动态绑定允许你在运行时替换彼此具有相同接口的对象，这种可替代性被称为多态性，它是面向对象系统中的一个关键概念，它允许客户端程序在仅持有某个接口的情况下对对象进行操作。多态性简化了客户端的定义，将对象彼此分离，并允许它们在运行时改变客户端与对象之间的关系。

设计模式通过识别关键元素以及接口传递时需要的数据类型来帮助你定义接口。设计模式也可能制定了什么方法不要放在接口中。备忘录模式就是一个很好的例子，它描述了如何封装和保存对象的内部状态，以便以后可以将对象恢复到该状态。该模式规定备忘录对象必须定义两个接口：一个允许客户端持有和复制备忘录的受限接口，以及一个只有原始对象可用于在备忘录中存储和检索状态的特权接口。

设计模式还指定了接口之间的关系。特别是，它们通常需要某些类具有类似的接口，或者它们对某些类的接口施加约束。例如，装饰器模式和代理模式都要求装饰器对象和代理对象的接口与装饰父对象和代理父对象相同。在访问者中，访问者接口必须说明访问者可以访问的所有类对象。

#### 说明对象的实现

到目前为止我们都没有说明我们究竟应该如何实现一个对象。一个对象的实现取决于它的类，类决定了对象的内部数据，对外的展示以及这个对象可以采取的应为操作。

基于OMT（在附录B中总结）的记号将类表示为一个方块，它的标题是类的名称，用粗体表示。下面紧接着是操作名，用普通字体表示，在一个分割的横线之后是属性名，用普通字体表示。

![1-3](/Users/tangdaye/git-repos/notes/png/设计模式/1/3.png)

*图1.3 一个基本的类的表示*

方法的返回类型和属性的类型是可选的，因为我们并不会假定一个固定的类型实现语言。

对象是由一个类实例化得到的，对象又被称为类的一个实例。实例化一个对象的过程包括为对象的内部数据（由实例化的变量组成的）分配空间，并且将这些数据与操作联系起来。通过实例化类，我们可以得到许多对象。

虚线箭头线表示实例化另一个类的对象的类，箭头指向实例化对象的类。

![1-4](/Users/tangdaye/git-repos/notes/png/设计模式/1/4.png)

*图1.4 实例和实例化之间的关系*

通过类的继承机制，我们可以从已有的类中获得新的类。一个子类的实例化对象会获得所有子类定义的数据和操作，也会获得父类定义的数据和操作。我们定义用三角形形状的箭头表示子类关系。

![1-5](/Users/tangdaye/git-repos/notes/png/设计模式/1/5.png)

*图1.5 子类与父类之间的关系*

抽象类的主要目的是为它的子类定义一个通用的接口，抽象类会将它部分或者全部的实现推迟到子类中完成，因此抽象类是不能被实例化的。由抽象类定义的，没有具体实现的方法被称为抽象方法，任何不抽象的类被称为具体类。

子类可以优化和重新定义其父类的行为操作，更具体地说，类可以覆盖由其父类定义的操作与行为，重写机制使子类有机会用与父类完全不同的方式处理请求。 类继承允许您通过扩展其他类来定义类，从而可以轻松定义具有相关功能的对象族。

抽象类的名称以倾斜类型显示，以便将它们与具体类区分开来，倾斜体也用于表示抽象操作的名称。 一张图可以包括用于方法实现的伪代码，伪代码将出现在一个盒子中，并用虚线连接到它对应的方法。

![1-6](/Users/tangdaye/git-repos/notes/png/设计模式/1/6.png)

*图1-6 抽象类和它的子类*

混合类是一个旨在为其他类提供可选接口或功能的类。 它类似于抽象类，因为它不打算实例化。 混合类需要多重继承：

![1-7](/Users/tangdaye/git-repos/notes/png/设计模式/1/7.png)

*图1-7 混合类和它子类*

### 类与接口继承

正确的理解一个对象的类和它的类型是很有必要的。

对象的类定义了对象的实现方式，该类定义了对象的内部状态及其操作的实现。相反，对象的类型仅指其接口，也就是它可以响应的请求集。对象可以有多种类型，不同类的对象也可以具有相同的类型。

当然，类和类型之间存在密切关系。因为类定义了对象可以执行的操作，所以它也定义了对象的类型，当我们说一个对象是一个类的实例时，我们也是在说，该对象支持该类定义的接口。

像C++和Eiffel这样的语言使用类来指定对象的类型及其实现。 Smalltalk程序不声明变量的类型，因此，编译器不会检查分配给变量的对象类型是否为变量类型的子类型。发送消息需要检查接收者的类是否实现了消息，但是不需要检查接收者是否是特定类的实例。

理解类继承和接口继承（或子类型）之间的区别也很重要。类继承根据另一个对象的实现来定义对象的实现。简而言之，它是代码共享的机制。相反，接口继承（或子类型）描述了何时可以使用对象代替另一个对象。

类的继承和接口的实现是两个很容易混淆的概念，因为很多语言都没有对这两者做出明显的区分。在C++和Eiffel中，继承既是指类的继承，也是接口的实现。在C++中，标准的实现接口的方式是公开的继承一个纯虚的类。对纯虚的类的私有继承可以看成是实现接口的一个近似。在Smalltalk中，继承仅意味着类的继承，只要这些实例支持对变量值执行的操作，您就可以将任何类的实例分配给变量。

尽管几乎所有的继承都不（显式地）区分类的继承与接口实现，人们还是在实践生活中总结了两者之间的区别，Smalltalk程序员通常认为为子类就是子类型（虽然有一些众所周知的例外），C ++程序员则经常通过抽象类定义的类型来操作对象。

许多设计模式都依赖于这种区别。 例如，责任链模式中的对象必须具有公共接口，但通常它们不共享共同的实现。 在组合模式中，组件定义了一个公共接口，但组合通常定义了一个通用实现。 命令，观察者，状态和策略模式通常使用纯接口的抽象类来实现。

### 面向接口编程，而不是面向实现

类的继承从机器编码上来只是通过复用父类中的代码来扩展功能的机制。它允许你以旧的类的形式定义一个新的类型的对象。它让你几乎能够完全不用代价的实现一个类，并且从现有的类当中继承到你想要的几乎所有功能。

但是，继承的重用只是完成了任务的一半。另一半任务在于，定义实现了同一个接口的对象族的能力也很重要。为什么？因为程序的多态性取决于它。

恰当地使用继承的话，所有的从共同抽象类中继承的类都将拥有相同的接口。这意味着子类仅需要添加或覆盖操作，而不会隐藏父类的操作。这样做的好处是，所有需要用抽象类作为参数或者返回值的时候，都可以用抽象类的子类来完成。

仅仅根据抽象类定义的接口来操作对象有两个好处：

- 只要对象遵循客户期望的接口，客户端就不会知道到它们使用的特定对象类型。
- 客户端仍然不知道实现这些对象的类，它只知道定义接口的抽象类。

这极大地减少了子系统之间的耦合性，从而引出了可重用的面向对象设计的以下原则：

面向接口编程，而不是面向实现编程。

不要将变量声明为特定具体类的实例，相反，只定义由抽象类定义的接口。 你会发现这是本书中设计模式的共同主题。

当然，您必须在系统中的某处实例化具体类（即指定一个特定实现），并且创建模式（抽象工厂模式，建造者模式，工厂方法，原型方法和单例模式）可以实现这一点。通过抽象化过程对象创建过程，这些模式为你提供了许多在实例化时透明地将接口与其实现相关联的方法。以上的创建模式可确保您的系统是根据接口而非实现来编写的。

### 在工作中设计可重用的组件

很多人都能理解对象，接口，类和继承这些概念，难的是，如何运用它们来构造灵活可重用的软件，设计模式可以帮助你做到这一点。

#### 继承VS组合


