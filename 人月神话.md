### 人月神话笔记

> 在很多方面，管理一个大型的计算机编程项目和其它行业的大型工程很相似——比大多数程序员所认为的还要相似，在很多另外的方面，它又有差别——比大多数职业经理所认为的差别还要大。

传统工程项目和软件工程项目的关系并不是简单的包含于被包含关系。程序员会处于对自己的个人崇拜或是自我陶醉，将软件工程和传统工程完全分开，而职业经理从成本的角度来看，将软件工程看做是传统工程的一个分支。

> 经验数据表明，相同功能的编程产品的成本，至少是已经过测试的程序的三倍。因为一些意想不到的交互会产生许多不易察觉的 bug，测试工作将会非常耗时，因此相同功能的编程系统构件的成本至少是独立程序的三倍。总的来说，人们追求的目标，即软件系统产品，其成本将会是可以独立程序成本的9倍

从独立程序到人们用到的软件之间经历了两个步骤的演变，先是独立程序经过部件集成，称为编程系统，编程系统需要经过完整的规格和详尽的测试，才会成为软件系统产品。

> 首先，我们对估算技术缺乏有效的研究，更加严肃地说，它反映了一种悄无声息，但并不真实的假设——一切都将运作良好。第二，我们采用的估算技术隐含地假设人和月可以互换，错误地将进度与工作量相互混淆。第三，由于对自己的估算缺乏信心，软件经理通常不会有耐心持续地进行估算这项工作。第四，对进度缺少跟踪和监督。其他工程领域中，经过验证的跟踪技术和常规监督程序，在软件工程中常常被认为是无谓的举动。第五，当意识到进度的偏移时，下意识(以及传统)的反应是增加人力。这就像使用汽油灭火一样，只会使事情更糟。越来越大的火势需要更多的汽油，从而进入了一场注定会导致灾难的循环。

1. 开发过程的运作是否会一直良好?所有的编程人员都是乐观主义者。原因在于，传统工程的由于需要一定的物理介质，例如锤子，钉子，车床等，因此传统工程的失败一部分可以归咎于这些介质的失灵或者不服从我们的思路，但软件是一种特殊的工业产品，它纯粹是人思维的结果，因此人们没有可以责怪的介质，从人的“骄傲性”和“自大性”上来说，程序员总是会认为软件产品实现过程中不会出现问题，至少是不会出现不在在自己掌控范围内问题（下周差不多能做好，明天一定交付，这个bug10分钟改好）。
2. 人与月能不能简单互换？人数和时间的简单互换有一个非常严苛的前提，那就是它假设参与人员之间没有任何的沟通，这在软件开发领域是不可能的。当任务不可被分解，在时间上具有时序性时，增加人手不会有任何作用。例如做化学实验，一个耗时2个小时的实验，一个人做是2小时，两个人做绝不会变成1个小时。当任务在时间上可以被分解，但是需要沟通的任务，团队规模较小（5人以内）的时候，在团队交流十分顺畅，人数在某些程度上可以和时间互换，但是当团队规模持续性扩大时，能缩减的时间非常有限，甚至会出现时间反向增长的情况。这其中，培训所占时间是线性的，但是沟通所占的时间是二次的，这个增长速率十分可怕。
3. 在估算不准确的情况下，产品经理会坚持估算工作量吗？对项目进度估算受限于项目本身和用户对项目的期待情况。从项目本身来看，软件产品，尤其是在编码完成以后的阶段，花费的时间基本上不可以预料，由于程序员的乐观性和软件产品的复杂性，测试带来的时间开销与预期之间的出入会非常大（一方面程序员认为自己的代码不会出什么问题，另一方面软件十分复杂会出现程序员根本无法预知的问题）。从客户对项目的期待情况来看，客户的紧迫程度会使得产品经理对软件开发做出不合理的进度安排。这两个问题摆在产品经理面前，产品经理能够使用的东西却十分有限，基本只能靠自己的直觉。
4. 进度出现问题时，单纯的增加人力是有好处的吗？简单的数学推导会告诉我们，在某些情况下（例如版本中期）增加人手，不仅不会对产品进度带来积极的影响，反而会推着产品走向更深的泥潭，在产品经理经验不足的情况下，如果继续增加人手，最终软件的发布时间会越来越拖后，这不仅是时间上的拖后，在这段拖后的时间里，各种各样的事情都有可能发生，例如需求变更，市场变化，人心变化等等。这个问题类比于沼泽问题，当你两条腿陷入沼泽时，花更大力气对挣脱沼泽是有好处的吗？

>大型项目的每一个部分由一个团队解决，但是该队伍以类似外科手术的方式组建，而并非一拥而上。也就是说，同每个成员截取问题某个部分的做法相反，由一个人来进行问题的分解，其他人给予他所需要的支持，以提高效率生产产力。

外科医生式的团队是典型的工程化思想，或者说“流水线”式思想，即有一个主程序员，他直接对计算机程序负责，负责设计实现整个软件。但是他随时有可能需要各类资源，包括文档，机器，人员管理等，需要有专门的人员提供支持。运作时，观点的不一致性会交由外科医生统一处理。但和中心化的架构类似的问题在于，外科医生式团队对主程序员的要求较高，主程序员出现的问题可能会导致严重的后果。

>是否要有一位杰出的精英，或者说是结构设计师的贵族专制，和一群创造性天分和构思被压制的平民编程实现人员?

系统架构师即便到了今天仍然是“权贵“一样的所在。客观上来说，为了保持系统在概念上的完整性和一致性，以便获得较好的易用性，软件世界的秩序的确是”贵族专治“的。如果实行普遍的民主，不管是可能的好心还是蓄意的破坏，众人的意见将会将软件系统撕个粉碎。从今天的视角来看，大的软件系统仍然是少数的结构设计师带着一群”平庸“的程序员在做，而小的软件系统压根没有或者说只有很少的”架构“的概念，基本上沿用传统成熟的架构。然而这并不能说底层实现人员的工作是没有创造性的，实现人员的工作解决了系统除了易用性之外几乎所有的问题，和架构是一样是有创造性的实践活动。

>想要成功，结构师必须1.牢记是开发人员承担创造性和发明性的实现责任，所以结构师只能建议，而不能支配;2.时刻准备着为所指定的说明建议一种实现的方法，同样准备接受其他任何能达到目 标的方法;3.对上述的建议保持低调和平静;4.准备放弃坚持所作的改进建议;

尽管这些话像是程序员自我吹捧的语句，但是它真的出自一位架构师之口！从人在团体中的认知感和荣誉感来说，架构师作为所谓的”贵族阶级“，他们在事实上就对整个项目有着更高层次的理解，理应有着更多的权力，或者说可以支配更多的事情，在自己提出的想法被驳回时，也很难保持低调与平静，更难放弃自己的想法，这是人之常情；但是从工程学的角度来讲，架构师与程序员之间的竞争不会对整个工程进度带来进步，而软件的最终创造者是程序员，因此架构师必须要做出让步与妥协。这一点无疑是很残酷的，也是和科学精神格格不入的-”整个技术很先进，为什么不用？“”因为我们都不会用，培训起来太贵“。但是工程往往只要”够用“即可，不需要”最好“。

>在设计第一个项目时，他会面对不断产生的装饰和润色功能。这些功能都被搁置在一 边，作为“下一个”项目的内容。第一个项目迟早会结束，而此时的结构师，对这类系统充满了十足的信心，熟练掌握了相应的知识，并且时刻准备开发第二个系统。 第二个系统是设计师们所设计的最危险的系统。 

”第二个系统“误区是架构师无法避免的问题。架构师在第一个项目中处于对自己的怀疑和否定，而小心翼翼没有使用的新技术和新思想，这使得他在第二个项目中很容易”放飞自我“，使得无辜的系统成为架构师才华宣泄的对象。这样设计出来的系统往往是功能堆砌，设计浪费的系统。避免”第二个系统“误区的办法就是，一定要让一个至少有两个类似系统的架构师来把关重要的架构决定。

>在大多数计算机项目中，机器和手册之间往往会在某一天出现不一致，人们通常会忽略手册。因为与机器相比，手册更容易改动，并且成本更低。

这一点似乎是毋庸置疑的。在我们日常开发中，经常会遇到代码与文档不一致的情况，在小团体构建的情况下，这种事情一般就是开个小会商量一下就过去了，责任人也比较好找，不管是修改代码还是修改文档都比较简单（通常情况下我们会修改文档，因为代码修改起来比较麻烦）。但是项目上了规模，上了流水线之后，代码与文档不一致的情况不是那么简单就可以解决的，尤其是接口相关的代码。我的想法是，与其后面一次一次小改小闹的修改文档，不如从头开始就严格的遵守文档来写代码，偶尔出现的不一致情况也是修改代码而遵循文档，这样的成本与修改文档带来的风险比起来还是很小的。

>因此，我们把会议分成两个级别:周例会和年度大会——这实际上是一种非常有效的方式。

以最近今年互联网应用发展的速度来看，周例会和年度会都已经不能满足快速的迭代周期，更高效的开发运维一体化手段DevOps慢慢流行了起来。但在后面会看到，这些都是次要的问题，如果不解决主要问题，整个软件的生产效率不会有太大的提升。

>因为左手不知道右手在做什么，所以进度灾难、功能的不合理和系统缺陷纷纷出现。随着工作的进行，许多小组慢慢地修改自己程序的功能、规模和速度，他们明确或者隐含地更改了一些有效输入和输出结果用法上的约定。

依旧是沟通问题。在大型软件开发过程中，沟通问题一直是一个老大难问题。从系统角度来看，沟通不顺畅直接的后果是系统前后不一致，从人员角度来看，沟通不顺畅会导致人员心理不平衡，人心慌动，浮躁不安等。有效的沟通手段包括电话，会议或者文档，现代软件开发过程中，电话（或者当面或者即时通讯）是最常用的手段，但是这个手段是存在一些问题的，首先就是没有记录，无论是有意还是无意，两个人忘记了对话的内容或是记错了对话的内容导致程序出问题的时候，经常需要第三方介入，这很大程度上降低了工作效率。从我的工作经验来看，工作是有很多时间花在了”对齐“这件事上，例如开发说这个功能规格书上面没写的，测试说这个需求虽然没有文档，但是当时某个需求人员亲口和我说要这么做，于是他们连通电话会议，把一个可能在千里之外现场的需求人员拉过来像是”对质“一样的询问。这个过程无疑是效率很低的，而且这样的场景出现在很多地方，我觉得是需要避免的，方法就在于保存文档和记录，使得有据可查。从我个人的软件开发实践来看，在工作岗位上，每个程序员每天留出4-5个小时独立设计，自我编码是很重要的。这段时间内，程序员应该避免所有的打扰，包括可能存在的沟通与交流问题。这段时间内，程序员或者反思自己的设计问题，或者开发新的需求，否则程序员很容易陷入一种怪圈，就是一天到晚都在交流，一点事都没干-这里可能也不是一点事都没干，还是有收获的，只是不明显，或者说程序员自己感受不到自己的产出，这对程序员来说是一个相当消极的暗号。

> $工作量 = (常数)×(指令的数量)^{1.5}$

这个公式表明，在编码数量增加时，工作量的增加并不是线性的，多余的工作量包括计划，编制文档，人员培训，系统集成等等。更糟糕的是，工作量增加的更快，平均每个人的工作效率反而更低了。在代码行数较少时，每个程序员都会了解整个系统的全貌，从而更快速的编写程序，在代码行数扩张时，多余花在沟通上的时间也是不可忽略的。这也从侧面反映了，单纯的增加程序员数量是没有好处的。

>同任何开销一样，规模本身不是坏事，但不必要的规模是不可取的。

这是同样非常工程化的一段论述，作为一个产品经理，你不可能想一个计算机科学家一样，要么不计成本的使用资源（研究大数据领域的最新算法），要么十分节俭的控制资源（研究最小化开销算法）。你必须在适合程序员开发的资源和客户能够接受的资源之间找到一个平衡点，从这一点来看，规模控制既是一个项目上的工作，也是一个技术上的工作。

> 任何管理任务的关注焦点都是时间、地点、人物、做什么、资金

从工程角度来看，何时，何地，何人，做什么，资金这几个是任何项目启动时必须要首先解决的弄清楚的问题，这一点上软件工程和传统工程区别不大。软件工程唯一有些区别的地方在于这些计划的更改速度会比较快，简单说，软件的不确定性影响了从项目启动到项目结束的每一个环节。

> 因此，为舍弃而计划，无论如何，你一定要这样做。
>
> 唯一不变的就是变化本身

在软件工程中，唯一不变的就是变化本身。这一点在原型设计时尤为明显。当你费劲心思编写出一个符合客户原始要求的原型时，遇到了或者客观或者主观问题，其中客观问题包括客户需求变更，客户需求描述有误，主观问题包括自身的失误，自身需求理解偏差等等，这时候这个原型是交付还是不交付呢？我想这个问题的解决方案只有一个，那就是不要费尽心思编写和设计原型系统，多尝试几个简单的原型。

> 他观察到不愿意为设计书写文档的原因，不仅仅是由于惰性或者时间压力。相反，设计人员通常不愿意提交尝试性的设计决策，再为它们进行辩解。“通过设计文档化，设计人员将自己暴露在每个人的批评之下，他必须能够为他的每个结果进行辩护。

这个说法很有意思，它分析了一些程序员不愿意书写文档（或者不愿意变更文档）的原因。设计的文档化使得一切“有据可查”，就像我之前说的，这是一个无法辩驳的证据。设计人员出于对自身在团体中地位的保护，不愿意书面化一些高风险设计。我觉得解决这个问题的办法也是多尝试，可以书写一些“尝试性设计文档”。

>程序维护中的一个基本问题是——缺陷修复总会以(20-50)%的机率引入新的 bug。所以整个过程是前进两步，后退一步

开发运维一体化（DevOps）可以部分解决运维过程中新引入bug问题，即运维修改的bug也作为开发的一部分，并加入到测试流水线中。然而这还是没有解决软件开发的根本问题，即如何抽象现实世界复杂的各类事物，使他们变成模型。

>那么，上述工具（指高级语言）的传统反对意见有哪些呢?这里有三点:它无法完成我想做的事情;目标代码过于庞大;目标代码运行速度过慢。

成书的时代离我们稍微有些遥远，可以从只言片语中感受一下当时的编程环境，顺便膜拜一下作者的高瞻远瞩。不过限于时代，作者还是在考虑编译环境的多样性来选择高级语言。

>我确信在十年内，自顶向下进行设计将会是最重要的新型形式化软件开发方法。

自顶向下，逐步求精的设计是现在主流设计方法之一，也是最容易理解的。这种设计方法可以很好地避免功能模块之间的功能耦合，并保证模块内的内聚性，这是分而治之思想在软件设计领域的应用场景。

> 然而，通常灾祸来自白蚁的肆虐，而不是龙卷风的侵袭。同样，项目进度经常以一种难以察觉，但是残酷无情的方式慢慢落后。

软件项目的失败往往并不是由机器宕机，项目组彻底重组等重大变故引起的。就像之前开玩笑所说，“好期待今天机房起火啊这样明天就不用上班了”，这种变故基本上不存在。项目的失败基本上都是由于一点一滴的延迟拖后，一点点的沟通不及时造成的。多人合作项目时，可能一个人延后半天等于全组进度延后半天，如果用人月转化理论的话，延后的人月量将是人数的线性函数。而在现实生活中，这种延后是很正常的，大家也不会觉得有什么奇怪的，但是最后的结局就是，整个项目的进度遭到了毁灭性地打击。此外，个人的延后会滋生一种很可怕的想法，那就是“怕什么，反正别的人也没做完，他没做完我就没法向下做，所以我拖一会也没关系”。这个想法在个人来看似乎是正确的，但是计算到整个工作量里的时候是另一种方式。所以，时刻保持快速的进度，对于团队中的每个人来说都很重要，只要有一个人掉队，慢慢就会带动整个团队的滞后，这也是为什么软件产品总是延期的原因吧。

>没有任何技术或管理上的进展，能够独立地许诺十年内使生产率、可靠性或简洁性获得数量级上的进步。

软件开发是否一定那么困难呢？软件开发有没有类似银弹消灭狼人一样，可以消灭一切困难的办法？答案是否定的，软件工程在根本上就是困难的，因为软件开发中最困难的部分是规格化、设计和测试某些概念上的结构，这些概念包括数据结合，数据条目之间的关系，算法，功能调用等，这部分困难的源头在于现实世界的复杂性，不可见性和可变性。软件实体不会有任何两个相同的部分（如果有会被合并），复杂度是软件的本质特性。人们常说拨开迷雾见月明，软件开发过程就像是，你辛辛苦苦拨开了一点点迷雾，但是月亮本身就是暗的，你依然看不见月亮。