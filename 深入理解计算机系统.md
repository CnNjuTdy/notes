# 深入理解计算机系统

## 第一章 计算机系统漫游

计算机系统是由软件和硬件构成的，它们共同工作来运行应用程序。所有的计算机系统都有着相似的硬件和软件组件，他们执行的功能也是类似的。

> code/intro/hello.c

### 1.1 信息是位+上下文

源程序是一个由0和1组成的位（比特）序列，8个位被组织成一组，称为字节。大部分现代计算机用ascll码来表示文本字符。如果一个文件只由ascll字符组成，这个文件被称为文本文件，所有其他文件都是二进制文件。磁盘中的所有信息，包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上的数据，都是由一串比特组成的。

区别同一个比特序列的不同含义需要用到上下文，一个相同的比特串可能表示整数，浮点数，字符串或者机器指令。

### 1.2 程序被其他程序翻译成不同的格式

一个c语言程序需要经过以下步骤逐步翻译之后，变成一个机器可执行程序：

- 预处理阶段：预处理器cpp将文本文件.c翻译成文本文件.i
- 编译阶段：编译器ccl将文本文件.i翻译成文本文件.s
- 汇编阶段：汇编器as将文本文件.s汇编成二进制文件.o
- 链接阶段：链接器ld链接我们的源文件.o和库文件.o生成最后的可执行文件

### 1.3 了解编译系统如何工作是大有益处的

有一些重要的原因促使程序员必须知道编译系统是如何工作的

- 优化程序性能
  - 一个switch是否比嵌套的if-else更高效？
  - 一个函数调用的开销是多大？
  - while循环比for循环更高效吗？
  - 指针引用比索引更有效吗？
  - 为什么本地变量比参数要高效？
- 理解链接时出现的错误
  - 静态变量与全局变量的区别是什么？
  - 不同的c文件中定义同一个全局变量的结果是什么？
  - 静态库和动态库的区别是什么？
  - 为什么有些链接错误到运行时才会被发现？
- 避免安全漏洞
  - 理解数据和控制信息存储在程序栈上的方式会引起的后果

### 1.4 处理器读并解释储存在内存中的指令

#### 1.4.1 系统的硬件组成

冯诺依曼架构的计算机主要组成部分包括：

- 总线：连接其他部分并进行数据信号和控制信号传输的"高速路''，每次能够传输的数据量大小被称为一个“字”，通常是32位或者64位（4字节或者8字节）。
- I/O设备：与外界交互的联系通道。每个I/O设备通过一个控制器与I/O总线连接，例如USB控制器，图形适配器，磁盘控制器，打印机控制器，网络控制器等。I/O总线通过I/O桥与系统总线相连。
- 主存：主存是一个临时存储设备，用来存放程序和程序用到的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片构成的，因此主存不具备记忆性，从逻辑上来看，主存是一个线性的字节数组，每个字节都一个唯一的地址与之对应。与C程序对应的变量存储需要的字节大小是根据类型变化的，例如整型和单精度浮点数是4个字节，双精度浮点数是8个字节。
- 处理器：处理器的核心是大小为一个字的寄存器，称为程序计数器（PC），程序计数器中保存的内容是内存中保存的一条机器语言指令。从系统通电开始，到系统断电，处理器一直在不断地执行程序计数器指向的命令。具体的命令集合被称为处理器的指令集，典型的指令类型包括：加载指令，存储指令，计算指令，跳转指令。

#### 1.4.2 运行hello程序

- 当我们在shell中输入./hello并敲击回车键时，shell程序就知道我们输完了所有指令。shell会执行一系列操作将磁盘上的hello复制到主存。通过直接存储器（DMA）技术，数据可以直接从磁盘到达主存，而不需要处理器从中调度。
- 一旦hello的二进制代码和数据加载到主存，处理器就开始执行hello程序main函数中的机器语言指令，这些指令把”hello，world\n“字符串从内存复制到寄存器，再从寄存器复制到图形控制器，最后显示在屏幕上

### 1.5 高速缓存至关重要

计算机消耗了很多时间把信息从一个地方搬运到另一个地方。处理器读取寄存器的速度是读取主存速度的100倍，读取主存速度是读取硬盘速度的1000万倍，因此系统设计者在cpu中添加了高速缓存，保存了一部分主存中读取的文件。意识到高速缓存存在的程序员将可以把程序性能提升一个数量级。

### 1.6 存储器设备的层级结构

将（每字节）造价更高，容量更小，读取速度更快的存储设备放在最前，典型的计算机存储设备层级是：寄存器-L1高速缓存-L2高速缓存-L3高速缓存-主存-本地磁盘-远程磁盘。

存储器分级的主要思想是上一层的存储器作为下一层存储器的高速缓存。程序员也可以利用存储器分层机制来提高程序性能。

### 1.7 操作系统管理硬件

在应用程序和真正的硬件之间，操作系统充当着管家的角色，所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统的主要功能有两个，一是防止硬件被失控的应用程序滥用，二是提供简单一致的机制来控制复杂的低级设备。

操作系统中用进程，虚拟内存和文件三个概念来涵盖处理器，主存和I/O设备这几个硬件概念。其中进程概念涵盖三者，虚拟内存概念涵盖主存和设备，文件概念主要针对设备。

#### 1.7.1 进程

进程是操作系统对计算机正在运行的程序的一种抽象。在一个系统上可以运行多个进程，而每个进程都好像独占地使用硬件。只考虑单CPU情形，由于cpu和内存读取，硬件读取之间的速度差异性，cpu往往会”并发地“执行许多程序，即有许多个进程在占用cpu，这是通过处理器在进程中切换来实现的。操作系统实现交错执行的机制被称为上下文切换。

操作系统需要保存跟踪进程运行的各种状态信息，也就是上下文。具体到某个时刻，cpu只能执行一个进程的代码。当操作系统决定把控制权从当前进程转移到某个新的进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后转交控制权。新进程会从上次停止的地方开始，继续占用cpu，执行代码。

从一个进程到另一个进程的操作是由内核完成的，内核是操作系统常驻主存的部分，当应用程序需要执行操作系统操作。例如读写文件，控制权会传递给内核，内核执行被请求的代码之后，控制权会返回给应用程序。内核是一系列进程的代码和数据结构的集合。

#### 1.7.2 线程

现代系统中，一个进程实际上由多个称为线程的执行单元组成，每个线程都在进程的上下文中。多线程之间可以更好地共享数据，因此线程为模型的编程会更加高效。当有多处理器可用时，多线程有一种使得数据运行得更快的办法。

#### 1.7.3 虚拟内存

虚拟内存为每个进程提供了一个假象，即每个进程都单独的占用主存，每个进程看到的内存是一致的，称为虚拟地址空间。但实际上，在进程生成的时候，操作系统会给它分配一块物理地址空间，操作系统将会维护虚拟地址空间与物理地址空间之间的映射。

进程的虚拟地址空间从低位到高位分别是下面几块：

- 内核虚拟内存：不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。
- 栈：位于用户虚拟地址空间的顶部的是用户栈，编译器用它来实现函数的调用。
- 共享库：用于存放c标准库和数学库之类的共享库
- 堆：当程序使用molloc或者free之类的代码来申请或释放运行时空间时，运行时堆会扩张或者收缩来满足应用程序的要求
- 程序代码和数据：对于所有进程来说，代码都是从固定地址开始的，这个地址就是程序代码和数据区的起始地址。

#### 1.7.4 文件

操作系统把所有的I/O设备，包括磁盘，键盘，显示器甚至网络都看成了文件。文件向应用提供了一个统一的视图来看待系统中可能含有的各种各样的I/O设备。

### 1.8 系统之间利用网络来通信

系统并不是一个孤立的软件和硬件的几何体。实际上，系统可以通过网络设备（也是一种I/O设备）来与其他系统联系到一起。当系统从主存复制一串字符到网络适配器时，数据流通过网络流向另一台机器，这个过程和数据从主存到硬盘是类似的。随着因特网的出现，将信息从一台主机复制到另一台主机已经是计算机系统最重要的用途之一。

### 1.9 重要主题

系统不仅仅是硬件，系统是硬件和系统软件互相交织的集合体，它们必须共同协作来达到运行应用程序的目的。

#### 1.9.1 Amdahl定律

定律的主要内容是，当我们对系统的一部分进行加速时，整体性能的提升取决于该部分的重要程度和加速程度。假如加速部分所占比例是$\alpha$，加速比是$k$，那么$S = \frac{1}{(1-\alpha)+\alpha/k}$。

从这个定理可以看出，如果加速部分所占比例$\alpha$比较小，即使$k$很大，对整体的性能也没有很大帮助。换句话说，要想显著加速整个系统，必须提升全系统中相当大部分的速度。

当$k \rightarrow \infin$时，$S=\frac{1}{1-\alpha}$，这表明，即使将某一部分（例如20%）的速度加快到可以忽略不计，对整个系统的性能提升也只有25%。

#### 1.9.2 并发和并行

在数字计算机的历史上，驱动进步的持续动力有两个，一是让计算机做得更多，另一个是让计算机做得更快。因此我们会想要让处理器同时做更多的事情。并发指一个同时具有很多活动的系统，并行指的是用并发来使得系统运行得更快。并行可以在计算机多个抽象层次上运用：

- 线程级别并发：但处理器的县城切换，多处理器的同时多线程
- 指令级别并行：流水线的使用
- 单指令多数据并行：单个指令多和数据的并行计算

#### 1.9.4 计算系统中抽象的重要性

抽象概念在计算机科学和程序设计中都是一个很重要的概念。在程序设计中，通常为一组函数设计一个简单易用的API。在计算机科学中，操作系统的进程，虚拟内存和文件都是重要的抽象概念，虚拟机甚至可以为操作系统提供一个抽象。

### 1.10 小结

- 计算机系统是由硬件和软件组成的
- 总线是连接计算机组件的通路，处理器来解释存放在主存里的二进制指令，主存是一个临时存储组件，I/O设备是计算机与外界交互的统一接口
- 由于计算机花费了许多时间在搬运数据上，因此需要高速缓存和存储分级技术。
- 操作系统是硬件与软件之间的媒介，操作系统提供的主要抽象是进程，虚拟内存和文件

## 第二章 信息的表示和处理

现代计算机存储和处理的信息都是二值信号，它可以很容易地表示，存储和传输。将位组合在一起，并赋予它某种解释的方法，我们就能够表示任何有限集合的元素。对于一个二进制数字系统，位组能用来编码非负数，对于一个文档，位组能用来编码字母和符号。

数字符号有三种主要的编码方式，无符号可以表示大于等于0的数字，补码编码是表示符号整数的最常见方式，浮点数编码是表示实数以2为基数的表示方式，因此这种表示方式在表示小数时绝大多数是不精确的，仅是一个近似的范围。计算机的数字运算基于数字符号的编码方式，大量的计算机安全漏洞都是由于计算机运算的微妙细节引发的。

### 2.1 信息存储

大多数计算机使用8位的块，也就是一个字节作为最小的可寻址的内存单位。机器级程序会把内存视为一个非常大的字节数组，称为虚拟内存。内存的每一个字节有一个唯一的编号，称为它的地址，所有可能地址的集合称为虚拟地址空间。C语言中的指针，无论它指向的是一个整数，一个结构或是某个其他的程序对象，都是某个存储块的第一个字节的虚拟地址。C编译器把指针的类型信息和指针保存起来，就可以根据指针的值来生成不同的机器级别代码。换句话说，C编译器知道指针所指的数据类型，但是机器并不需要知道，机器只需要根据虚拟地址进行内存寻址读取数据即可。

#### 2.1.1 十六进制表示法

C语言可以用0x开头表示后面的数值是一个十六进制的数。十六进制，二进制，十进制的互相转化是编写机器级程序的常见任务。

#### 2.1.2 字数据大小

32位字长的机器限制了虚拟地址空间是$2^{32}$字节，即4GB，而64位字长的机器的虚拟地址空间将会是16EB，这种字长的提升是向前兼容的。可移植性的一个重要方面就是使得程序对不同的数据类型的确切大小是不敏感的。

#### 2.1.3 寻址和字节顺序

对于跨越多个自己的数据类型，有两个重要的问题需要考虑。一是这个对象的地址是多少，二是内存中如何排列这些字节。在几乎的所有的机器上，多字节的对象被存储为连续的字节序列，对象的地址为所用字节中最小的地址。有些机器选择在内存中按照从大到小的顺序排列连续的字节，这种办法称为大端法，另一些相应的，使用小端法。

字节顺序在大部分时候不重要，以下几种情形除外：

- 通过网络传递二进制数据的时候：需要遵守已经建立的关于字节顺序的规则
- 阅读表示整数数据的字节序列的时候：发生在检查机器级程序的时候
- 编写规避正常的类型系统的时候：对系统级变成是很有必要的

在C语言中，`sizeof`运算符可以获得对象所使用的字节数，这在不同操作系统，不同字长的机器上并不是一个定值，因此较好得实现了可移植性。

#### 2.1.4 表示字符串

文本数据比二进制数据有更强的平台独立性。

#### 2.1.5 表示代码

二进制代码很少能在不同平台上进行移植。

#### 2.1.6 布尔代数简介

布尔代数定义在$\{0,1\}$上，主要运算符包括~ | & ^，分别表示非，或，与，与或。可以这四个运算扩展到位向量的运算，即定义出二进制序列的布尔代数。

位向量的一个作用在于映射集合。例如$a=[a_{\omega-1}.\dots.a_2,a_3]$可以用来编码任何集合$A \sub \{0,1,2,\dots,\omega-1\}$，其中$i \in A$当且仅当$a_i=1$。这种技巧在表示屏蔽信号，设计掩码时非常有用。

#### 2.1.7 C语言中的位运算

C语言中的位运算可以运用在任何“整型”的数据上。

#### 2.1.8 C语言中的逻辑运算

C语言中还提供了一组逻辑运算符号，它们和位运算的标记很像，但是作用完全不同。

#### 2.1.9 C语言中的移位运算

对于操作数$x$，$x<<k$会返回$x$左移$k$位以后的值，其中$x$最左端的$k$个值会被丢弃，右边会添加$k$个0。相应的运算是右移运算符$x>>k$，它有两种支持形式，逻辑右移和算数右移。逻辑右移和左移操作是一样的，即右边丢弃k个值，左边添加k个0，算数右移是在右边丢弃k个值，在左端补充k个最高有效位的值。C语言几乎所有的编译器和机器的组合都限定算术右移，但是对于无符号整数来说，它的右移是逻辑右移。

### 2.2 整数表示

有两种方式可以表示无符号整数和所有整数，他们的数学属性和机器实现方面是密切相关的。

#### 2.2.1 整型数据类型

C语言的有符号整数中，负数会比正数多1个，例如32位有符号整数的范围是$[-2^{31},2^{31}-1]$，出现这种情况的原因是使用了补码表示法。

#### 2.2.2 无符号数的编码

无符号整数的编码采用原码编码，即简单的二进制向整数换算即可。因此，使用$\omega$位原码，能够编码的最小整数是$[00\dots00]$，最大整数是$[11\dots11]$，即范围是$[0,2^\omega-1]$一共$2^\omega$个数。原码的编码过程是一个双射，即这个过程是一一对应的。

#### 2.2.3 补码编码

在补码编码中，字的最高位是负权重的，其余位和无符号编码相同，即向量$x=[x_{\omega-1},x_{\omega-2},\dots,x_0]$表示整数$n=-x_{\omega-1}+\sum_\limits{i=0}^{\omega-2}x_i2^{i}$。当最高位是1时，表示负数，否则表示正数（或0）。使用$\omega$位补码，能够编码最小整数是$[10\dots00]$，最大整数是$[01\dots11]$，即范围是$[-2^{\omega-1},2^{\omega-1}-1]$一共也是$2^\omega$。补码的编码过程也是一个双射，这个工程也是一一对应的。从补码范围可以看出负数的最小值并没有对应的正数，这会导致一些细微的错误。

#### 2.2.4 有符号整数和无符号整数之间的转换

C语言中，无符号整数和有符号的整数之间的强制转换并不改变位向量，只是改变了位向量的解释方法，即从位的角度而不是从数的角度。

有符号整数转化成无符号整数：最高位是1时，$T2U_\omega(x) = x+2^\omega$，最高位是0时，$T2U_\omega(x)=x$

无符号整数转化成有符号整数：最高位是1时，$U2T_\omega(x)=x-2^\omega$，最高位是1时，$U2T_\omega(x)=x$

#### 2.2.5 C语言中有符号整数和无符号整数

C语言中，不特定声明的正数都是有符号整数，并且两者之间的转换都是基于位的。

#### 2.2.6 扩展一个数的位表示

无符号数的扩展只需要在无符号数的位表示前加0即可，例如$(1001_u=0000 \ 1001_u)$ （9）

有符号数（补码表示）的扩展需要在位表示之前添加最高位即可$(1001=1111 \ 1001)$（-7）

#### 2.2.7 截断数字

截断无符号数截取后k位之后获得的数字是原数字除以$2^k$的余数

截断有符号数截取后k位之后获得的数字是原数字除以$2^k$的余数的补码表示

#### 2.2.8 关于有符号数和无符号数的争议

有符号数和无符号数的隐式强制转换导致了某些非直观的行为，从而导致导致程序错误，并且还很难发现。因此除了C语言之外几乎所有编程语言都不支持无符号数。

### 2.3 整数的运算

#### 2.3.1 无符号加法

两个$\omega$位的无符号整数，它们相加的结果可能是$\omega+1$位。这种字长的膨胀要求，如果想要完整地表示算数运算的结果，那么对字长不能有任何的限制。在大部分编程语言中，这一点是做不到的，因此无符号整数的加法存在着溢出的情况。这种加法写作$+^{u}_{\omega}$

当$x+y<2^\omega$时，$x+^{u}_{\omega}y=x+y$

当$x+y \ge 2^\omega$时，运算结果会溢出，即$x+^{u}_{\omega}y = x+y-2^\omega$

 在C语言中，程序不会对溢出报出任何异常。判定是否溢出的方法是，如果$s = x+^{u}_{\omega}y$，那么当且仅当$s<x$或者$s<y$的时候发生了溢出。

对于一个$\omega$位整数x，它的加法逆元$-^{u}_{\omega}x$是

如果$x=0$，那么$-^{u}_{\omega}x=0$，否则$-^{u}_{\omega}x=2^\omega-x$

#### 2.3.2 补码加法

补码加法有三种可能的情形

当$x+y \ge 2^{\omega-1}$时，运算结果正溢出，$x+^{u}_{\omega}y=x+y-2^\omega$

当$-2^{\omega-1}\le x+y <2^{\omega-1}$时，$x+^{u}_{\omega}y=x+y$

当$x+y \le -2^{\omega-1}$时，运算结果负溢出，$x+^{u}_{\omega}y = x+y+2^\omega$

判定是否溢出的办法时，当且仅当$x<0,y<0,x+y>0$时发生了负溢出，$x>0,y>0,x+y<0$时发生了正溢出。

#### 2.3.3 补码的非

对于一个$\omega$位补码整数x，它的加法逆元$-^{u}_{\omega}x$是

如果$x=-2^{\omega-1}$，那么$-^{u}_{\omega}x=-2^{\omega-1}$，否则$-^{u}_{\omega}x=-x$

可以用取反加一法获得补码的非

#### 2.3.4 无符号乘法

两个$\omega$位无符号整数的乘法是先直接相乘，再取后$\omega$位。

#### 2.3.5 补码乘法

两个$\omega$位补码的乘法是先直接相乘，取后$\omega$位，然后再转换成补码。即$T2U_\omega(x*^t_\omega y)=U2T_\omega(x^‘*^u_\omega y^`)$

#### 2.3.6 乘以常数

由于乘法所需要时间较长，编译器常常会采用移位+加法的方式来代替乘法。

与2的k次幂相乘时，相当于把原数（无论是无符号还是补码）左移k位。

与不是2的幂次相乘时，编译器会优化这个乘法，例如$x*14=(x<<4)-(x<<1)$，可以转化成两步移位和一步减法。

#### 2.3.6 除以2的幂次

除以2的k次幂的结果向下取整相当于把原数（无论是无符号还是补码）右移k位。

其他整数的除法并不能推广使用这种右移运算。

#### 2.3.7 关于整数运算的最后思考

C语言的某些规定很奇怪，例如无符号整数的规定，这些规定很有可能会出现一些意想不到的错误。

### 2.4 浮点数

在刚开始时，浮点数的定义和计算规则很多样，现在使用的是IEEE的标准754。

#### 2.4.1 二进制小数

$b_mb_{m-1}\dots b_{0}b_{-1}\dots b_{-n}=\sum_\limits{i=-n}^m{2^i}$可以近似的表示一个小数，如果仅考虑有限长度的编码，这种编码格式有许多小数无法表示，例如0.2，0.3等等。刑辱$0.11111111$的可以表示恰好小于1的数，这里用$1-\epsilon$来表示。

#### 2.4.2 IEEE浮点数表示

IEEE的浮点数有三个组成部分

- 32位浮点数
  - 第31位是符号位S，1代表负数，0代表整数，对于数值0的符号位有单独解释。
  - 第30-23共8位阶码，这可以是个负数，表示对小数位置的权重
  - 第22-0共23位小数，它的范围是$[1,2-\epsilon]$，因为它前面有默认的1
- 64位浮点数
  - 第63位是符号位，62到52共11位是阶码E，51到0共52位是小数M

以32位浮点数为例，对于阶码的不同，有三种不同的可能性：

- 阶码不是全0也不全是1（不等于0也不等于255）：这是规格化情况
  - 如果用e表示阶码的无符号整数（范围是1到254）这时E = e-127（范围-126到127）
  - 小数部分M是1.f之后，范围是从$1.0\dots0$到$1.1\dots1$，十进制表示是1到$2-\epsilon$
  - 最终的小数是$b=(-1)^SM2^{e}$

- 阶码全位0：这是非规格化情况
  - 这时$E = 1-127=-126$
  - 小数分M=0.f，即这个时候小数部分是没有前面默认的1的
  - 最终的小数是$b=(-1)^SM2^{e}$
- 阶码全位1
  - 如果小数部分全是0，这时候表示正负无穷，符号位是1表示负无穷，符号位是0表示正无穷
  - 如果小数部分不全是0，这时候表示NaN

#### 2.4.3 数字示例

